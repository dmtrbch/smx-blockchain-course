{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"S00-intro/L1-course-intro/","text":"Welcome! The blockchain field develops at an incredibly fast pace. This course will give you a solid foundation of blockchain principles. It will also introduce you to the tools used to build blockchain projects today. It can be overwhelming to enter such a rapidly developing field and we hope to give you the mental model to incorporate new information as it comes in. Course content In this course, I start off by teaching you about the underpinnings of the blockchain and show how it all comes together to allow us to build the next generation of web applications. We will start with an overview of what we call blockchain primitives: The technology brought together underneath the name blockchain. We'll then dive deeper into the specifics of the Ethereum protocol and learn how those blockchain primitives show up there. Next, we'll move on to understanding how to write smart contracts. I introduce you to Solidity, a programming language for Smart Contracts that lets you interact with the Ethereum Virtual Machine. We'll learn about Truffle so you can try out your new Solidity skills! We'll also discuss smart contract design patterns and security for your smart contracts. After that, we'll introduce you to developer tooling, including Web3 libraries, and other development frameworks. Last, we'll discuss the way in which people are innovating blockchain development, with an introduction to Decentralized Finance (DeFi). While this material may seem a bit overwhelming, it's important to have it available to you as you continue to develop in the space. You can always come back later to reread stuff. And I won't be testing you on it :) So without further ado, I wish you the best of luck, and let\u2019s get started!","title":"Welcome!"},{"location":"S00-intro/L1-course-intro/#welcome","text":"The blockchain field develops at an incredibly fast pace. This course will give you a solid foundation of blockchain principles. It will also introduce you to the tools used to build blockchain projects today. It can be overwhelming to enter such a rapidly developing field and we hope to give you the mental model to incorporate new information as it comes in.","title":"Welcome!"},{"location":"S00-intro/L1-course-intro/#course-content","text":"In this course, I start off by teaching you about the underpinnings of the blockchain and show how it all comes together to allow us to build the next generation of web applications. We will start with an overview of what we call blockchain primitives: The technology brought together underneath the name blockchain. We'll then dive deeper into the specifics of the Ethereum protocol and learn how those blockchain primitives show up there. Next, we'll move on to understanding how to write smart contracts. I introduce you to Solidity, a programming language for Smart Contracts that lets you interact with the Ethereum Virtual Machine. We'll learn about Truffle so you can try out your new Solidity skills! We'll also discuss smart contract design patterns and security for your smart contracts. After that, we'll introduce you to developer tooling, including Web3 libraries, and other development frameworks. Last, we'll discuss the way in which people are innovating blockchain development, with an introduction to Decentralized Finance (DeFi). While this material may seem a bit overwhelming, it's important to have it available to you as you continue to develop in the space. You can always come back later to reread stuff. And I won't be testing you on it :) So without further ado, I wish you the best of luck, and let\u2019s get started!","title":"Course content"},{"location":"S00-intro/L2-why-learn/","text":"Why Learn Blockchain? Most people in crypto came here initially because of the allure of money. Either we missed an opportunity to buy, are looking for an opportunity to grow our salary, or see an opportunity for a killer app. There's no shame in that! I do hope you come for the money and stay for the paradigm shift, though. Blockchain promises to upend the current top-down information systems in our world. Currently, most users of the internet surrender their personal data to centralized databases and services. To achieve this paradigm shift, blockchain relies fundamentally on two fields of computer science: Distributed Computing and Cryptography . We will cover these topics in the Fundamentals section of the course. This paradigm shift requires changes from the developer and the user. In the next section of the course, we'll go over what the protocol-layer changes of blockchain mean for you as a developer. I'll then introduce you to Solidity, the language for developing smart contracts, as well as the tools you'll need to build. I'll also discuss the changes for the user, including how requiring private key signatures dramatically changes user workflow. While there's enormous promise with blockchain development, it requires an awareness of the paradigm shift and an expertise in the fundamental concepts underpinning it. Otherwise, we are inevitably going to recreate the same, centralized monolith we have today. External Resources Things That Matter Outside DeFi (Vitalik Buterin) Y Combinator: Building for the Blockchain (2017) Dated but interesting! Why It's Hard to \"Get\" Bitcoin: The Blockchain Spectrum The Promise of Blockchain: Vinay Gupta Cryptocurrencies (Last Week Tonight)","title":"Why Learn Blockchain?"},{"location":"S00-intro/L2-why-learn/#why-learn-blockchain","text":"Most people in crypto came here initially because of the allure of money. Either we missed an opportunity to buy, are looking for an opportunity to grow our salary, or see an opportunity for a killer app. There's no shame in that! I do hope you come for the money and stay for the paradigm shift, though. Blockchain promises to upend the current top-down information systems in our world. Currently, most users of the internet surrender their personal data to centralized databases and services. To achieve this paradigm shift, blockchain relies fundamentally on two fields of computer science: Distributed Computing and Cryptography . We will cover these topics in the Fundamentals section of the course. This paradigm shift requires changes from the developer and the user. In the next section of the course, we'll go over what the protocol-layer changes of blockchain mean for you as a developer. I'll then introduce you to Solidity, the language for developing smart contracts, as well as the tools you'll need to build. I'll also discuss the changes for the user, including how requiring private key signatures dramatically changes user workflow. While there's enormous promise with blockchain development, it requires an awareness of the paradigm shift and an expertise in the fundamental concepts underpinning it. Otherwise, we are inevitably going to recreate the same, centralized monolith we have today.","title":"Why Learn Blockchain?"},{"location":"S00-intro/L2-why-learn/#external-resources","text":"Things That Matter Outside DeFi (Vitalik Buterin) Y Combinator: Building for the Blockchain (2017) Dated but interesting! Why It's Hard to \"Get\" Bitcoin: The Blockchain Spectrum The Promise of Blockchain: Vinay Gupta Cryptocurrencies (Last Week Tonight)","title":"External Resources"},{"location":"S00-intro/L3-course-tips/","text":"How to be Successful in this Course Growth Mindset First and foremost, foster a growth mindset and take full advantage of the course. Understanding takes time. There will be struggles and frustration when learning something new, especially something as difficult as blockchain development. Fortunately, enrolling in a continuing education course such as this indicates that you already exhibit a growth mindset. Here is a short video that shows the differences and talks about how you can demonstrate a growth mindset throughout this course. Ask All the Questions There is a common myth about the \"all-knowing\" developer who never needs to ask any questions. This person simply does not exist. Developers of all skill-levels need to ask questions! All developers use a search engine to find what they need. Do not hesitate to do these things! As you're going through the course, we recommend you take some time to write down a question about something you learned. Then, take time during the next week to answer that question. On the following Friday, make sure you've answered your question(s) and write another. Give Yourself Time to Understand It\u2019s impossible to learn these concepts by hearing them once. Instead, you\u2019ll hear concepts multiple times and begin to learn more each time around. Maybe you\u2019ll start programming and it makes some more sense. Finally, you\u2019ll try to explain it to someone and realize there\u2019s a part you don\u2019t understand, which you then have to go back and learn. This is the process of learning blockchain, and if you can accept it, it will take the pressure off trying to perfectly understand something the first time you hear it. Instead, try to let it wash over you, ask questions when they come up, but we\u2019re also going to dive into the unknown, pull you up to catch breath, then do it again! Always keep in mind, if you find yourself truly stuck and need assistance, post a question into the relevant course chat and I will for sure try to assist. We are all here to learn and grow.","title":"How to be Successful in this Course"},{"location":"S00-intro/L3-course-tips/#how-to-be-successful-in-this-course","text":"","title":"How to be Successful in this Course"},{"location":"S00-intro/L3-course-tips/#growth-mindset","text":"First and foremost, foster a growth mindset and take full advantage of the course. Understanding takes time. There will be struggles and frustration when learning something new, especially something as difficult as blockchain development. Fortunately, enrolling in a continuing education course such as this indicates that you already exhibit a growth mindset. Here is a short video that shows the differences and talks about how you can demonstrate a growth mindset throughout this course.","title":"Growth Mindset"},{"location":"S00-intro/L3-course-tips/#ask-all-the-questions","text":"There is a common myth about the \"all-knowing\" developer who never needs to ask any questions. This person simply does not exist. Developers of all skill-levels need to ask questions! All developers use a search engine to find what they need. Do not hesitate to do these things! As you're going through the course, we recommend you take some time to write down a question about something you learned. Then, take time during the next week to answer that question. On the following Friday, make sure you've answered your question(s) and write another.","title":"Ask All the Questions"},{"location":"S00-intro/L3-course-tips/#give-yourself-time-to-understand","text":"It\u2019s impossible to learn these concepts by hearing them once. Instead, you\u2019ll hear concepts multiple times and begin to learn more each time around. Maybe you\u2019ll start programming and it makes some more sense. Finally, you\u2019ll try to explain it to someone and realize there\u2019s a part you don\u2019t understand, which you then have to go back and learn. This is the process of learning blockchain, and if you can accept it, it will take the pressure off trying to perfectly understand something the first time you hear it. Instead, try to let it wash over you, ask questions when they come up, but we\u2019re also going to dive into the unknown, pull you up to catch breath, then do it again! Always keep in mind, if you find yourself truly stuck and need assistance, post a question into the relevant course chat and I will for sure try to assist. We are all here to learn and grow.","title":"Give Yourself Time to Understand"},{"location":"S00-intro/L4-keeping-up/","text":"Keeping Up With Blockchain Development As we mentioned, the blockchain space moves very fast. Courses like this are great way to get you on the ride but you'll need to keep up with the pace. Luckily, there are plenty of places to read the latest and greatest happening in the space, particularly Ethereum. Here's where I suggest you get started. Twitter Twitter Lists from Aftab Hossain (DCinvestor) @ConsensysAcad Twitter List from John Brennan @ConsenSys Basecamp's list of blockchain Cultural Figures Go through this list and follow them! Reddit r/Ethereum r/EthFinance r/EthStakers r/CryptoCurrency r/EthDev Newsletters Signal ConsenSys' Developer Newsletter Week In Ethereum A weekly round-up of all things Ethereum EthHub Another weekly news round-up Economics Design (detailed dives into DeFi and crypto topics) Decrypt the Web 3 news site has a newsletter you can sign up for which delivers top stories from the day Tally Great roundup of DAO governance votes DeFi Weekly Daily Gwei Websites The Ethereum Wiki Rekt Glassnode Insights The Defiant Decrypt Basecamp and Basecamp's Blue Chip Defi Docs and Audits Ethereum Stack Exchange Mirror.xyz Read about this interesting writing platform here The Daily Ape YouTube Finematics Critical way of learning about blockchain concepts! Bankless Peep an EIP Eat the Blocks Dapp University Patrick Collins Nader Dabit Dan Finlay on How Ethereum Works Coin Bureau Podcasts Zero Knowledge Unchained Epicenter Mapping out Eth 2 Bankless Uncommon Core Learning Paths EthernautDAO Decentralized organization focussed on training developers to become blockchain developers and get them jobs! Discord here How to Get Into Web 3 as a Developer (Nader Dabit) Anett Rolikova's README for Crypto Beginners Learning Resources from EthernautDAO DeFi Developer Roadmap Ethereum.org's Developer Guide BuidlGuidl Cleverflare Resources to Learn Web 3 How to Become a DeFi Developer Rabbithole.gg Place to learn and earn tokens Zapper Learn Educational resources around DeFi KERNEL Resources From Gitcoin's KERNEL incubator program Consensys' Ethereum Developer Tools List EthereumDev.io Comprehensive Solidity Tutorials CryptoZombies Visual Overview of Ethereum in 116 Slides QuestBook-Learn Solidity A Discord server for beginners in Solidity Chainshot Educational resources on Solidity UseWeb3 Mega-Aggregator of Ethereum educational resources, including courses, tutorials, newsletters","title":"Keeping Up With Blockchain Development"},{"location":"S00-intro/L4-keeping-up/#keeping-up-with-blockchain-development","text":"As we mentioned, the blockchain space moves very fast. Courses like this are great way to get you on the ride but you'll need to keep up with the pace. Luckily, there are plenty of places to read the latest and greatest happening in the space, particularly Ethereum. Here's where I suggest you get started.","title":"Keeping Up With Blockchain Development"},{"location":"S00-intro/L4-keeping-up/#twitter","text":"Twitter Lists from Aftab Hossain (DCinvestor) @ConsensysAcad Twitter List from John Brennan @ConsenSys Basecamp's list of blockchain Cultural Figures Go through this list and follow them!","title":"Twitter"},{"location":"S00-intro/L4-keeping-up/#reddit","text":"r/Ethereum r/EthFinance r/EthStakers r/CryptoCurrency r/EthDev","title":"Reddit"},{"location":"S00-intro/L4-keeping-up/#newsletters","text":"Signal ConsenSys' Developer Newsletter Week In Ethereum A weekly round-up of all things Ethereum EthHub Another weekly news round-up Economics Design (detailed dives into DeFi and crypto topics) Decrypt the Web 3 news site has a newsletter you can sign up for which delivers top stories from the day Tally Great roundup of DAO governance votes DeFi Weekly Daily Gwei","title":"Newsletters"},{"location":"S00-intro/L4-keeping-up/#websites","text":"The Ethereum Wiki Rekt Glassnode Insights The Defiant Decrypt Basecamp and Basecamp's Blue Chip Defi Docs and Audits Ethereum Stack Exchange Mirror.xyz Read about this interesting writing platform here The Daily Ape","title":"Websites"},{"location":"S00-intro/L4-keeping-up/#youtube","text":"Finematics Critical way of learning about blockchain concepts! Bankless Peep an EIP Eat the Blocks Dapp University Patrick Collins Nader Dabit Dan Finlay on How Ethereum Works Coin Bureau","title":"YouTube"},{"location":"S00-intro/L4-keeping-up/#podcasts","text":"Zero Knowledge Unchained Epicenter Mapping out Eth 2 Bankless Uncommon Core","title":"Podcasts"},{"location":"S00-intro/L4-keeping-up/#learning-paths","text":"EthernautDAO Decentralized organization focussed on training developers to become blockchain developers and get them jobs! Discord here How to Get Into Web 3 as a Developer (Nader Dabit) Anett Rolikova's README for Crypto Beginners Learning Resources from EthernautDAO DeFi Developer Roadmap Ethereum.org's Developer Guide BuidlGuidl Cleverflare Resources to Learn Web 3 How to Become a DeFi Developer Rabbithole.gg Place to learn and earn tokens Zapper Learn Educational resources around DeFi KERNEL Resources From Gitcoin's KERNEL incubator program Consensys' Ethereum Developer Tools List EthereumDev.io Comprehensive Solidity Tutorials CryptoZombies Visual Overview of Ethereum in 116 Slides QuestBook-Learn Solidity A Discord server for beginners in Solidity Chainshot Educational resources on Solidity UseWeb3 Mega-Aggregator of Ethereum educational resources, including courses, tutorials, newsletters","title":"Learning Paths"},{"location":"S01-fundamentals/M0-paper-blockchain/","text":"A Paper Blockchain To give you an overview of the blockchain, let's walkthrough a simple example. We'll then walk through each of the elements that makes up the blockchain protocol. https://streamable.com/z0ffs5","title":"Index"},{"location":"S01-fundamentals/M0-paper-blockchain/#a-paper-blockchain","text":"To give you an overview of the blockchain, let's walkthrough a simple example. We'll then walk through each of the elements that makes up the blockchain protocol. https://streamable.com/z0ffs5","title":"A Paper Blockchain"},{"location":"S01-fundamentals/M1-intro/","text":"Fundamentals Despite the Bitcoin white paper being written in 2008, Bitcoin, and blockchain generally, should be seen as the continuation of decades of technological development. In this first section, Fundamentals, we'll learn what those developments are and how they combine to become what we call blockchain. This first section will lay the foundation for the rest of this course but we hope it will also broaden your understanding of computer programming, security and networking. The cryptographic and distributed computing tools you'll learn in this section are used in every facet of digital life. Online banking, communication networks, cloud providers, aerospace engineering and many more fields pull from similar starting points. By learning them here, you'll better your understanding of those systems, too. The Argument for Blockchain The Current State of Affairs In our financial transactions, we always use an intermediary, be it a bank or a credit card company. We use these institutions because they have cultivated and embodied in society our values of trust, security, and accessibility (You can call someone if you have a problem, there\u2019s a central website, for example) What's the Problem? However, in recent years, those values have been violated in different ways (financial crashes, data breaches, or monopolization leading to poor customer service), which has led people to question whether there's a different way these processes can be done . At the same time, there's been an unprecedented amount of digitalization that has also occurred in all parts of our life, but also finance\u2013 it's not unusual to cash a check by phone, or pay off a credit card or utility bill by computer. What's the Proposed Solution? Significant system failures and increased digitalization led blockchain developers to consider alternatives to centralized financial institutions. Specifically, they looked to develop a protocol for financial transactions. A protocol is the reason why, when you dial a phone number, there's not an operator on the other end connecting your line to another. Or, when you type in a web address, you don't first leave your house to get that data. These are protocols that have been developed which have eliminated intermediate, human-mediated steps. This is the value proposition of blockchain. A peer-to-peer protocol which allows people to interact directly with each other, rather than going through a third party. People are so excited about blockchain because it aims to make important transactions (financial transactions or identity confirmation) peer-to-peer, removing the need for a middle player. Services such as Twilio have automated text message and receiving by allowing programmers to simply import the Twilio library into their program and, presto! They can send and receive text messages. Blockchain protocols such as Ethereum can be seen in a similar light \u2013 import Ethereum libraries (such as web3.js) and you can begin programmatically sending and receiving money. Setting up a bank account takes weeks, but with Ethereum, you can setup accounts, transfer funds and much more all from within your program. The Ethereum protocol is strong enough to sustain financial transactions, but it can also support much more. You can use the distributed network to host self-executing programs. You can build decentralized systems of reputation, you can also persist global state in a secure, trustless way. All of these things are possible within the world of Ethereum. What Makes Up a Protocol? In the following modules, we're going to examine the elements engineers have used to build the peer-to-peer blockchain protocol. We'll then see how systems like Bitcoin and Ethereum join these separate elements together to make a wholly new product: blockchain. Last, we'll talk about the development of Bitcoin and how you can start playing with the Ethereum blockchain right from your browser.","title":"Index"},{"location":"S01-fundamentals/M1-intro/#fundamentals","text":"Despite the Bitcoin white paper being written in 2008, Bitcoin, and blockchain generally, should be seen as the continuation of decades of technological development. In this first section, Fundamentals, we'll learn what those developments are and how they combine to become what we call blockchain. This first section will lay the foundation for the rest of this course but we hope it will also broaden your understanding of computer programming, security and networking. The cryptographic and distributed computing tools you'll learn in this section are used in every facet of digital life. Online banking, communication networks, cloud providers, aerospace engineering and many more fields pull from similar starting points. By learning them here, you'll better your understanding of those systems, too.","title":"Fundamentals"},{"location":"S01-fundamentals/M1-intro/#the-argument-for-blockchain","text":"","title":"The Argument for Blockchain"},{"location":"S01-fundamentals/M1-intro/#the-current-state-of-affairs","text":"In our financial transactions, we always use an intermediary, be it a bank or a credit card company. We use these institutions because they have cultivated and embodied in society our values of trust, security, and accessibility (You can call someone if you have a problem, there\u2019s a central website, for example)","title":"The Current State of Affairs"},{"location":"S01-fundamentals/M1-intro/#whats-the-problem","text":"However, in recent years, those values have been violated in different ways (financial crashes, data breaches, or monopolization leading to poor customer service), which has led people to question whether there's a different way these processes can be done . At the same time, there's been an unprecedented amount of digitalization that has also occurred in all parts of our life, but also finance\u2013 it's not unusual to cash a check by phone, or pay off a credit card or utility bill by computer.","title":"What's the Problem?"},{"location":"S01-fundamentals/M1-intro/#whats-the-proposed-solution","text":"Significant system failures and increased digitalization led blockchain developers to consider alternatives to centralized financial institutions. Specifically, they looked to develop a protocol for financial transactions. A protocol is the reason why, when you dial a phone number, there's not an operator on the other end connecting your line to another. Or, when you type in a web address, you don't first leave your house to get that data. These are protocols that have been developed which have eliminated intermediate, human-mediated steps. This is the value proposition of blockchain. A peer-to-peer protocol which allows people to interact directly with each other, rather than going through a third party. People are so excited about blockchain because it aims to make important transactions (financial transactions or identity confirmation) peer-to-peer, removing the need for a middle player. Services such as Twilio have automated text message and receiving by allowing programmers to simply import the Twilio library into their program and, presto! They can send and receive text messages. Blockchain protocols such as Ethereum can be seen in a similar light \u2013 import Ethereum libraries (such as web3.js) and you can begin programmatically sending and receiving money. Setting up a bank account takes weeks, but with Ethereum, you can setup accounts, transfer funds and much more all from within your program. The Ethereum protocol is strong enough to sustain financial transactions, but it can also support much more. You can use the distributed network to host self-executing programs. You can build decentralized systems of reputation, you can also persist global state in a secure, trustless way. All of these things are possible within the world of Ethereum.","title":"What's the Proposed Solution?"},{"location":"S01-fundamentals/M1-intro/#what-makes-up-a-protocol","text":"In the following modules, we're going to examine the elements engineers have used to build the peer-to-peer blockchain protocol. We'll then see how systems like Bitcoin and Ethereum join these separate elements together to make a wholly new product: blockchain. Last, we'll talk about the development of Bitcoin and how you can start playing with the Ethereum blockchain right from your browser.","title":"What Makes Up a Protocol?"},{"location":"S01-fundamentals/M2-cryptography/L1-pub-key-crypto/","text":"Public Key Cryptography The first step in creating a peer-to-peer trust protocol system is to digitally confirm one's identity using mathematic principles. This video discusses how we use public key cryptography to do just that. https://streamable.com/hrjvs8","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L1-pub-key-crypto/#public-key-cryptography","text":"The first step in creating a peer-to-peer trust protocol system is to digitally confirm one's identity using mathematic principles. This video discusses how we use public key cryptography to do just that. https://streamable.com/hrjvs8","title":"Public Key Cryptography"},{"location":"S01-fundamentals/M2-cryptography/L2-pub-key-crypto-additional/","text":"Public Key Cryptography Public key cryptography is powerful in general because it is one of the few things on the planet that can create an asymmetric power imbalance. This means that, even if the largest corporation or government were to focus every available resource into figuring out a certain individual's private key, they will not be able to do it. Isn't that crazy!? This asymmetric power imbalance is so dramatic that in the 1990s, world governments fought against the use of public key cryptography. The argument was, because public key cryptography essentially cannot be broken, it represented a critical threat to the national security of governments like the United States. We'll discuss this history more in a following section, but know that at one point using this technology was almost illegal! Public key cryptography is powerful for blockchain specifically because it allows us to prove a message has been sent from a certain person holding a specific private key. This is a step in the direction of establishing identity in a peer-to-peer way. Remember, a blockchain protocol is trying to provide what banks or governments have previously provided but without those institutions as intermediaries. What public key cryptography does is mathematically prove a certain person holds a certain key. Consequences However, there's a big issue here. There's no way to determine who holds the key, just if they have the key. We are assuming the private key equals the owner of the assets, but what if someone steals your private key? This is a big security and user-experience issue for people coming into the blockchain and cryptocurrency world. As consumers, users are probably used to being able to reset their passwords, recover their funds if there's fraud, or at least reach out to a service and get assistance in case of trouble. At its most basic, with users handling their own private keys, almost all of this disappears. Even more troubling, regardless of the amount of messaging a user receives about protecting their private keys, many may not understand there is no safety net until it is too late. And for those users who are experienced, there are so many bad habits we've all developed as consumers which are hard to break. All this to say: Not trusting is expensive. Please be aware of how expensive it is, not only for yourself, but also for your users. Luckily, at the end of this section, we'll walk through some basic security considerations that anyone in the crypto space should adopt from Day 1 Moar on Keys There are a ton of additional resources for public key cryptography, so we're going to break them up into different sections: General Public Key Cryptography Resources , Blockchain / Ethereum-Specific Public Key Cryptography Resources and Advanced Public Key Cryptography Resources . ### General Public Key Cryptography Resources Know that in these examples, you will meet some lifetime friends, Alice and Bob. They are the most absolutely unimaginatively, Eurocentric named parties in every cryptographic key exchange (rather than using A and B). Please, please if you're ever teaching this to someone else use a more interesting name than Alice and Bob, like Akash and Basilia. But, it is the common way to discuss it and perhaps there's value in that commonality across cultures. Video & Interactive Code: ETH.Building with Key Pairs Excellent hands-on tutorial about public keypairs from Austin Griffith using his ETH.Build platform (highly recommended) Article: Public Key Cryptography (Wikipedia) A good starting place for folks to get an understanding of the terms and be able to dig into some of the background or deeper ideas. Video: End to End Encryption \u2014 Computerphile Introducing the general concepts behind using encryption in public networks Video: Gambling with Secrets \u2014 RSA Encryption Article: What is Asymmetric Encryption? Article: Keeping Secrets Secret (BBC) This is a valuable resource explaining, in simple visual terms, the modular arithmetic underpinning the security of public key cryptography, hashing (which we'll learn about next) and any other one-way or \"trapdoor\" functions. It illustrates how you cannot break a private key's encryption with brute-force but can easily validate it if you have the accompanying public key. Video: Secret Key Exchange \u2014 Computerphile Not public key encryption but good to know in terms of general cryptography mechanics Video: Elliptic Curves \u2014 Computerphile Going deeper into the Elliptic Curve encryption behind public key cryptography. Mini-Course: Basic Key Exchange Requires a free Coursera registration, but this is another general overview on the mechanics of key exchanges (not RSA encryption specifically) from Dan Boneh's Cryptography I course from Stanford University. ### Blockchain / Ethereum-Specific Public Key Cryptography Resources Now that you have an understanding of public key cryptography generally, let's dive into how it is used in blockchains, specifically Ethereum. The following links will mainly show how private keys are used to generate Ethereum accounts, which then become a stand-in for identity on the Ethereum network. Note that all Ethereum addresses start with the first two characters 0x , which is not actually part of the address but rather a prefix used to let programs know the address is coded in hexadecimal format. Book Excerpt: Keys and Addresses (Mastering Ethereum) Excerpt from Andreas Antonopoulos and Gavin Wood's excellent book, Mastering Ethereum available for free as an e-book through this GitHub repo. Article: How are Ethereum Addresses Generated? (Stack Overflow) A nice, thorough answer walking through the process of generating a private key to having an Ethereum address linked to that private key ### Advanced Public Key Cryptography Resources Coding Problem Set: Cryptopals This is an extremely advanced problem set series discussing applied cryptography generally. Not for the faint of heart!","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L2-pub-key-crypto-additional/#public-key-cryptography","text":"Public key cryptography is powerful in general because it is one of the few things on the planet that can create an asymmetric power imbalance. This means that, even if the largest corporation or government were to focus every available resource into figuring out a certain individual's private key, they will not be able to do it. Isn't that crazy!? This asymmetric power imbalance is so dramatic that in the 1990s, world governments fought against the use of public key cryptography. The argument was, because public key cryptography essentially cannot be broken, it represented a critical threat to the national security of governments like the United States. We'll discuss this history more in a following section, but know that at one point using this technology was almost illegal! Public key cryptography is powerful for blockchain specifically because it allows us to prove a message has been sent from a certain person holding a specific private key. This is a step in the direction of establishing identity in a peer-to-peer way. Remember, a blockchain protocol is trying to provide what banks or governments have previously provided but without those institutions as intermediaries. What public key cryptography does is mathematically prove a certain person holds a certain key.","title":"Public Key Cryptography"},{"location":"S01-fundamentals/M2-cryptography/L2-pub-key-crypto-additional/#consequences","text":"However, there's a big issue here. There's no way to determine who holds the key, just if they have the key. We are assuming the private key equals the owner of the assets, but what if someone steals your private key? This is a big security and user-experience issue for people coming into the blockchain and cryptocurrency world. As consumers, users are probably used to being able to reset their passwords, recover their funds if there's fraud, or at least reach out to a service and get assistance in case of trouble. At its most basic, with users handling their own private keys, almost all of this disappears. Even more troubling, regardless of the amount of messaging a user receives about protecting their private keys, many may not understand there is no safety net until it is too late. And for those users who are experienced, there are so many bad habits we've all developed as consumers which are hard to break. All this to say: Not trusting is expensive. Please be aware of how expensive it is, not only for yourself, but also for your users. Luckily, at the end of this section, we'll walk through some basic security considerations that anyone in the crypto space should adopt from Day 1","title":"Consequences"},{"location":"S01-fundamentals/M2-cryptography/L2-pub-key-crypto-additional/#moar-on-keys","text":"There are a ton of additional resources for public key cryptography, so we're going to break them up into different sections: General Public Key Cryptography Resources , Blockchain / Ethereum-Specific Public Key Cryptography Resources and Advanced Public Key Cryptography Resources . ### General Public Key Cryptography Resources Know that in these examples, you will meet some lifetime friends, Alice and Bob. They are the most absolutely unimaginatively, Eurocentric named parties in every cryptographic key exchange (rather than using A and B). Please, please if you're ever teaching this to someone else use a more interesting name than Alice and Bob, like Akash and Basilia. But, it is the common way to discuss it and perhaps there's value in that commonality across cultures. Video & Interactive Code: ETH.Building with Key Pairs Excellent hands-on tutorial about public keypairs from Austin Griffith using his ETH.Build platform (highly recommended) Article: Public Key Cryptography (Wikipedia) A good starting place for folks to get an understanding of the terms and be able to dig into some of the background or deeper ideas. Video: End to End Encryption \u2014 Computerphile Introducing the general concepts behind using encryption in public networks Video: Gambling with Secrets \u2014 RSA Encryption Article: What is Asymmetric Encryption? Article: Keeping Secrets Secret (BBC) This is a valuable resource explaining, in simple visual terms, the modular arithmetic underpinning the security of public key cryptography, hashing (which we'll learn about next) and any other one-way or \"trapdoor\" functions. It illustrates how you cannot break a private key's encryption with brute-force but can easily validate it if you have the accompanying public key. Video: Secret Key Exchange \u2014 Computerphile Not public key encryption but good to know in terms of general cryptography mechanics Video: Elliptic Curves \u2014 Computerphile Going deeper into the Elliptic Curve encryption behind public key cryptography. Mini-Course: Basic Key Exchange Requires a free Coursera registration, but this is another general overview on the mechanics of key exchanges (not RSA encryption specifically) from Dan Boneh's Cryptography I course from Stanford University. ### Blockchain / Ethereum-Specific Public Key Cryptography Resources Now that you have an understanding of public key cryptography generally, let's dive into how it is used in blockchains, specifically Ethereum. The following links will mainly show how private keys are used to generate Ethereum accounts, which then become a stand-in for identity on the Ethereum network. Note that all Ethereum addresses start with the first two characters 0x , which is not actually part of the address but rather a prefix used to let programs know the address is coded in hexadecimal format. Book Excerpt: Keys and Addresses (Mastering Ethereum) Excerpt from Andreas Antonopoulos and Gavin Wood's excellent book, Mastering Ethereum available for free as an e-book through this GitHub repo. Article: How are Ethereum Addresses Generated? (Stack Overflow) A nice, thorough answer walking through the process of generating a private key to having an Ethereum address linked to that private key ### Advanced Public Key Cryptography Resources Coding Problem Set: Cryptopals This is an extremely advanced problem set series discussing applied cryptography generally. Not for the faint of heart!","title":"Moar on Keys"},{"location":"S01-fundamentals/M2-cryptography/L3-hashing/","text":"Hashing The second step in creating a peer-to-peer trust protocol system is to digitally confirm the integrity of a file using mathematics. This ensures no one has tampered with a file. This video discusses how we use cryptographic hash functions to achieve this. https://streamable.com/rxr377","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L3-hashing/#hashing","text":"The second step in creating a peer-to-peer trust protocol system is to digitally confirm the integrity of a file using mathematics. This ensures no one has tampered with a file. This video discusses how we use cryptographic hash functions to achieve this. https://streamable.com/rxr377","title":"Hashing"},{"location":"S01-fundamentals/M2-cryptography/L4-hashing-additional/","text":"Hashing Cryptographic hash functions (also called hash functions or just hashes ) are essential to us building a decentralized trust protocol by providing three main things (use this cryptographic hash function sandbox to follow along): Uniqueness We can be assured if we put in the string dark wallet puzzle in a cryptographic function, it will always produce the same hash result. With a sufficiently large number of possibilities, this avoids the \u201chash collision\u201d problem, in that we don\u2019t have to worry about two strings getting the same hash. Avalanche Effect Small changes on the target string for a hash function leads to outsized effects. Change one letter in the string you hashed in the above example, maybe capitalizing the \"d\" in Dark wallet puzzle . You'll see it\u2019s not changed a little bit but a lot. This illustrates the second characteristic of a good hashing function \u2014 \u201cThe Avalanche Effect\u201d. This says a single change in the string will cause a successive series of changes that compound each other. Speed Cryptographic hash functions can also run incredibly fast with little overhead and still maintain their security. This is more of a logistical concern. The hashing function can\u2019t be too slow, otherwise it causes delays. But it also can\u2019t be too fast or it will be easier to find collisions. It needs to be fast for processing but slow for hacking. Cryptographic hash functions speed combined with the difficulty in deriving the target input makes them a one-way or \"trapdoor\" function \u2014 easy to go one way, near impossible to go the other. These three characteristics combine to help blockchains provide decentralized file integrity. Let's explain how. Hashing in Blockchains In the Bitcoin Whitepaper, Satoshi Nakamoto articulates the \"double-spend\" problem facing digital currencies: The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. To restate the problem: How do we know the transaction record is true and hasn't been tampered with? Hashing helps us with this. (The second point, proof of majority node agreement, we'll cover in the next Module on Distributed Consensus) Nakamoto proposes using hashing to create what they call a \"Timestamp Server\": The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash , such as in a newspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. from the Bitcoin Whitepaper The timestamp server leverages hash functions in one critical way. It includes the hash of the previous block into the hash of the current block. If any historical data in any of the previous blocks are altered, the changes will cascade throughout all the blocks after it. In this way, blocks of transaction data are chained together to form a blockchain \ud83e\udd2f \ud83e\udd2f \ud83e\udd2f. This chaining can only be effective in a large system because of those three characteristics of hash functions we discussed previously: Uniqueness (one string matches one hash), Avalanche Effects (one change in an input string creates outsized effects on the output) and Speed (hashes can be securely computed quickly at scale). Hash Chains as General Data Structures While Nakamoto's timestamp server uses hash chains, hash chains are found in many different sorts of computer science applications before and beyond blockchain. The version control software Git, for example, uses a hash chain, also called a Directed Acyclic Graph, to track changes of software over time. Challenge-Response schemes, used for user validation, also use the concept of a hash chain. Learning about hash functions and the associated hash chaining will give you great insights into these power data structures as well as programming data primitives like hash tables. Additional Links for Hashing ### General Hashing Material Interactive Code: Cryptographic Hash Function Sandbox A, simple nice way to see the characteristics of hash functions. Article: Why is 2^256 Secure? Explanation behind the enormous \"numberspace\" that virtually guarantees no collisions, and therefore uniqueness, when using hash functions based on large exponents. Video: Hashing Algorithms and Security (Computerphile) Video: SHA (Secure Hashing Algorithm) Explained (Computerphile) Article: How Hash Algorithms Work Article: Cryptographic Hash Function (Simple Wikipedia) ### Blockchain / Ethereum-Specific Hashing Material Interactive Code: ETH.Build Austin Griffith walks through Hash Functions using his ETH.Build platform (highly recommended). Article: Blockchain Underpinnings: Hashing (ConsenSys) Interactive Code: Cryptographic Hash Functions (ConsenSys / Josh Crites) Uses a platform called Observable to provide you with code you can run in the article! Lesson: Cryptographic Hash Functions (Khan Academy) ### Advanced Hashing Resources Coding: Bitcoin Whitepaper Exercises: Hashing This is a JavaScript-based exercise implementing the timestamp server outlined in the Bitcoin Whitepaper. It's the first in a larger problem set we'll also recommend you try later in this section.","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L4-hashing-additional/#hashing","text":"Cryptographic hash functions (also called hash functions or just hashes ) are essential to us building a decentralized trust protocol by providing three main things (use this cryptographic hash function sandbox to follow along): Uniqueness We can be assured if we put in the string dark wallet puzzle in a cryptographic function, it will always produce the same hash result. With a sufficiently large number of possibilities, this avoids the \u201chash collision\u201d problem, in that we don\u2019t have to worry about two strings getting the same hash. Avalanche Effect Small changes on the target string for a hash function leads to outsized effects. Change one letter in the string you hashed in the above example, maybe capitalizing the \"d\" in Dark wallet puzzle . You'll see it\u2019s not changed a little bit but a lot. This illustrates the second characteristic of a good hashing function \u2014 \u201cThe Avalanche Effect\u201d. This says a single change in the string will cause a successive series of changes that compound each other. Speed Cryptographic hash functions can also run incredibly fast with little overhead and still maintain their security. This is more of a logistical concern. The hashing function can\u2019t be too slow, otherwise it causes delays. But it also can\u2019t be too fast or it will be easier to find collisions. It needs to be fast for processing but slow for hacking. Cryptographic hash functions speed combined with the difficulty in deriving the target input makes them a one-way or \"trapdoor\" function \u2014 easy to go one way, near impossible to go the other. These three characteristics combine to help blockchains provide decentralized file integrity. Let's explain how.","title":"Hashing"},{"location":"S01-fundamentals/M2-cryptography/L4-hashing-additional/#hashing-in-blockchains","text":"In the Bitcoin Whitepaper, Satoshi Nakamoto articulates the \"double-spend\" problem facing digital currencies: The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. To restate the problem: How do we know the transaction record is true and hasn't been tampered with? Hashing helps us with this. (The second point, proof of majority node agreement, we'll cover in the next Module on Distributed Consensus) Nakamoto proposes using hashing to create what they call a \"Timestamp Server\": The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash , such as in a newspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. from the Bitcoin Whitepaper The timestamp server leverages hash functions in one critical way. It includes the hash of the previous block into the hash of the current block. If any historical data in any of the previous blocks are altered, the changes will cascade throughout all the blocks after it. In this way, blocks of transaction data are chained together to form a blockchain \ud83e\udd2f \ud83e\udd2f \ud83e\udd2f. This chaining can only be effective in a large system because of those three characteristics of hash functions we discussed previously: Uniqueness (one string matches one hash), Avalanche Effects (one change in an input string creates outsized effects on the output) and Speed (hashes can be securely computed quickly at scale).","title":"Hashing in Blockchains"},{"location":"S01-fundamentals/M2-cryptography/L4-hashing-additional/#hash-chains-as-general-data-structures","text":"While Nakamoto's timestamp server uses hash chains, hash chains are found in many different sorts of computer science applications before and beyond blockchain. The version control software Git, for example, uses a hash chain, also called a Directed Acyclic Graph, to track changes of software over time. Challenge-Response schemes, used for user validation, also use the concept of a hash chain. Learning about hash functions and the associated hash chaining will give you great insights into these power data structures as well as programming data primitives like hash tables.","title":"Hash Chains as General Data Structures"},{"location":"S01-fundamentals/M2-cryptography/L4-hashing-additional/#additional-links-for-hashing","text":"### General Hashing Material Interactive Code: Cryptographic Hash Function Sandbox A, simple nice way to see the characteristics of hash functions. Article: Why is 2^256 Secure? Explanation behind the enormous \"numberspace\" that virtually guarantees no collisions, and therefore uniqueness, when using hash functions based on large exponents. Video: Hashing Algorithms and Security (Computerphile) Video: SHA (Secure Hashing Algorithm) Explained (Computerphile) Article: How Hash Algorithms Work Article: Cryptographic Hash Function (Simple Wikipedia) ### Blockchain / Ethereum-Specific Hashing Material Interactive Code: ETH.Build Austin Griffith walks through Hash Functions using his ETH.Build platform (highly recommended). Article: Blockchain Underpinnings: Hashing (ConsenSys) Interactive Code: Cryptographic Hash Functions (ConsenSys / Josh Crites) Uses a platform called Observable to provide you with code you can run in the article! Lesson: Cryptographic Hash Functions (Khan Academy) ### Advanced Hashing Resources Coding: Bitcoin Whitepaper Exercises: Hashing This is a JavaScript-based exercise implementing the timestamp server outlined in the Bitcoin Whitepaper. It's the first in a larger problem set we'll also recommend you try later in this section.","title":"Additional Links for Hashing"},{"location":"S01-fundamentals/M2-cryptography/L5-digital-sig/","text":"Digital Signatures The third piece in creating a peer-to-peer trust protocol system is to digitally capture a user's intent using mathematical principles. This video discusses how digital signatures crystallize intent by using a combination of public key cryptography and cryptographic hash functions. https://streamable.com/jfzr1i","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L5-digital-sig/#digital-signatures","text":"The third piece in creating a peer-to-peer trust protocol system is to digitally capture a user's intent using mathematical principles. This video discusses how digital signatures crystallize intent by using a combination of public key cryptography and cryptographic hash functions. https://streamable.com/jfzr1i","title":"Digital Signatures"},{"location":"S01-fundamentals/M2-cryptography/L6-digital-sig-additional/","text":"Digital Signatures Up till now, we've looked at how blockchains use private keys as a decentralized form of identity and how hashing is used as a decentralized form of file integrity. We are now arriving at the last cryptographic element of our decentralized trust protocol, digital signatures. As the previous section discussed, digital signatures use a combination of the key signing and hashing to create what we're calling decentralized intent. Let's unpack what that means. In blockchain, the signature is made when a hash of the message is signed by the private key of the account holder. (The encryption process is also a hashing process, so it may be helpful to think of the signed transaction as a hash of a hash.) In practice, it looks like a normal hash except it can be decrypted using the sender's public key to confirm identity. This digital signature acts like a protective wrapping around transaction data, as the simplified image below shows: a signed blockchain transaction (simplified) The first, unsigned hash is formed by making a cryptographic hash of the Sender , Receiver and Amount data. The second, signed hash is formed by combining the Sender Receiver Amount and, most importantly, Hash data and signing all those fields. By creating these two successive hashes, we are creating a series of protective wrappings. A message that has a valid digital signature on it provides three different confirmations. It confirms: * Origin: From what we learned about public key cryptography, we can infer that if a private key digital signature is valid then the signed message really did come from the account associated with the public key. * Message Integrity: From what we learned about cryptographic hash functions, we know that the message has not been tampered with by anyone else * Intent: By signing the first hash, the owner of the private key is signalling their intent to execute whatever commands or agreements are contained in the message. In the non-blockchain world, the idea of capturing intent may seem fairly useless since you can't legally force someone to do something they do not want to do. Someone can sign a string saying, \"I'll pay you 100 pounds\" but you can't really do anything with that string. It's just pixels on a screen. The real power of digital signatures comes when the message within that digital signature can be executed, say on a blockchain protocol. In fact, the only significant messages in the blockchain world are bits of code that, when signed and validated, can be executed automatically by the blockchain protocol. (If this feels like a leap for you, that's okay, we're going to keep explaining it more.) Conclusion The decentralization of intent is the last piece of cryptographic primitives in this section. It's important for capturing intent but it's also significant because it relies entirely on two other primitives (public key cryptography and hash functions) for its existence. Digital signatures are emergent in this way, arising from simple-yet-powerful features to create something with equal importance. It's a good microcosm or analogy for the broader ecosystem and yet another example of emergence. Additional Resources Article: The Magic of Digital Signatures (MyCrypto)","title":"Index"},{"location":"S01-fundamentals/M2-cryptography/L6-digital-sig-additional/#digital-signatures","text":"Up till now, we've looked at how blockchains use private keys as a decentralized form of identity and how hashing is used as a decentralized form of file integrity. We are now arriving at the last cryptographic element of our decentralized trust protocol, digital signatures. As the previous section discussed, digital signatures use a combination of the key signing and hashing to create what we're calling decentralized intent. Let's unpack what that means. In blockchain, the signature is made when a hash of the message is signed by the private key of the account holder. (The encryption process is also a hashing process, so it may be helpful to think of the signed transaction as a hash of a hash.) In practice, it looks like a normal hash except it can be decrypted using the sender's public key to confirm identity. This digital signature acts like a protective wrapping around transaction data, as the simplified image below shows: a signed blockchain transaction (simplified) The first, unsigned hash is formed by making a cryptographic hash of the Sender , Receiver and Amount data. The second, signed hash is formed by combining the Sender Receiver Amount and, most importantly, Hash data and signing all those fields. By creating these two successive hashes, we are creating a series of protective wrappings. A message that has a valid digital signature on it provides three different confirmations. It confirms: * Origin: From what we learned about public key cryptography, we can infer that if a private key digital signature is valid then the signed message really did come from the account associated with the public key. * Message Integrity: From what we learned about cryptographic hash functions, we know that the message has not been tampered with by anyone else * Intent: By signing the first hash, the owner of the private key is signalling their intent to execute whatever commands or agreements are contained in the message. In the non-blockchain world, the idea of capturing intent may seem fairly useless since you can't legally force someone to do something they do not want to do. Someone can sign a string saying, \"I'll pay you 100 pounds\" but you can't really do anything with that string. It's just pixels on a screen. The real power of digital signatures comes when the message within that digital signature can be executed, say on a blockchain protocol. In fact, the only significant messages in the blockchain world are bits of code that, when signed and validated, can be executed automatically by the blockchain protocol. (If this feels like a leap for you, that's okay, we're going to keep explaining it more.)","title":"Digital Signatures"},{"location":"S01-fundamentals/M2-cryptography/L6-digital-sig-additional/#conclusion","text":"The decentralization of intent is the last piece of cryptographic primitives in this section. It's important for capturing intent but it's also significant because it relies entirely on two other primitives (public key cryptography and hash functions) for its existence. Digital signatures are emergent in this way, arising from simple-yet-powerful features to create something with equal importance. It's a good microcosm or analogy for the broader ecosystem and yet another example of emergence.","title":"Conclusion"},{"location":"S01-fundamentals/M2-cryptography/L6-digital-sig-additional/#additional-resources","text":"Article: The Magic of Digital Signatures (MyCrypto)","title":"Additional Resources"},{"location":"S01-fundamentals/M3-consensus/L1-consensus-intro/","text":"Consensus Now that we have the building blocks of a trustless protocol (public key cryptography, hash functions and digital signatures), let's see how blockchains (like Ethereum) combine them to create an entirely new system. This video mentions that a consensus mechanism is an \"economic\" mechanism. This is true only for consensus mechanisms in public blockchains. As we'll see in the next section, consensus mechanisms are used in many different fields besides blockchain. However, blockchain does introduce a novel form of consensus, trustless consensus, which relies on economic mechanisms. https://streamable.com/l40otl","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L1-consensus-intro/#consensus","text":"Now that we have the building blocks of a trustless protocol (public key cryptography, hash functions and digital signatures), let's see how blockchains (like Ethereum) combine them to create an entirely new system. This video mentions that a consensus mechanism is an \"economic\" mechanism. This is true only for consensus mechanisms in public blockchains. As we'll see in the next section, consensus mechanisms are used in many different fields besides blockchain. However, blockchain does introduce a novel form of consensus, trustless consensus, which relies on economic mechanisms. https://streamable.com/l40otl","title":"Consensus"},{"location":"S01-fundamentals/M3-consensus/L2-consensus-additional/","text":"Distributed Coordination: Consensus Protocols After learning about cryptography, we know how to create an identity, how to make sure no one has messed with a file, and how to capture a user's intent all in a decentralized peer-to-peer way. This is all well and good for current interactions or things we are doing now on a network, but how do we agree on things that have happened in the past? That is, how do actors in a network we coordinate and agree on the series of events that have led to the current state of the network? How do we know someone really does have digital money they can send to us and are not making it up? How do all the actors in the network then maintain that knowledge in a secure way? This is what we're going to learn in this module. To understand how all the actors in a network can coordinate and agree about the historical state of a blockchain network we will learn about consensus . Distributed consensus is not only used in blockchain, to be clear. Any internet service that needs to coordinate their servers all over the globe (which is all the major internet services) uses distributed consensus mechanisms to make that happen. Blockchain takes traditional distributed consensus one step further. We'll see what that step is once we understand the historical and fundamental principles of distributed computing. (Note: In this section, we will use the terms Distributed Computing , Distributed Systems , Distributed Consensus , and Distributed Coordination interchangeably. We'll also be speaking about consensus strictly in the computer scientific sense. Later in the course, we'll discuss consensus among people in a network, typically called governance .) Development of Distributed Computing Distributed Computing became an important field of study in the 1970s when airplanes started using electronic control systems. Airline manufacturers wanted to make sure that if a certain part of the electronics gave out while the plane was in the air, the whole plane wouldn't shut down. In the scenario of an airplane, the \"bad actor\" is not a hacker trying to purposefully disable the entire airplane, but rather a single part that is not behaving as it should. As a result, researchers began researching and developing consensus protocols for the airplane computer systems. At the most basic level, \"consensus protocols are used to allow computers to work together\" and \"let different servers agree on the state of a system.\" ( Software Engineering Daily ). For the airplane manufacturers, a good consensus protocol would continue to function with some errors. This way, if one or two things failed, the entire system wouldn't fail. The ability of a consensus protocol to adapt to failure is called resilience. Crucially, early work around distributed computing and consensus protocols dealt with non-adversarial systems . This meant that any of the faults that were happening in a computer network, like an airplane, were the result of natural system errors (power failure, faulty parts, etc), not some sort of active meddling or hacking. This has now developed to encompass much more than aerospace technology. As we mentioned before, it now also covers many digital services, such as: * Any multi-party real-time communication stream (like a social media feed) * An online media streaming service which requires multiple regional servers holding and updating the exact same information on customers * A search engine service that needs to maintain and update indexed information across many regions Consensus protocols help these systems maintain historical information also called state. Broadly speaking, state can be defined as a set of variables describing a certain system at a specific time. Let\u2019s describe that in a real-world situation. Take a look around at whatever environment you\u2019re in\u2013\u2013bus station, coffee shop, office\u2013\u2013and pick out a few variables you could use to describe it. If you\u2019re inside a room, you could describe any number of things: * The number of walls * The types of furniture * The placement of furniture * The number of people * The kind of light in the room Taken all together, these variables will paint a picture of the room. And if things change (say, you turn off a light), we'll update \"The kind of light in the room\" variable, which changes the state. If multiple people needed to maintain a record about the state of our room, we'd have to find a way to communicate this state change. Consensus protocols help us do exactly that: agree on a sequential series of system state which allows all network participants adhering to the consensus protocol to have a similar understanding of the historical changes adding up to the current network state. For a distributed computer network, state typically involves technical information about critical actors in a system. For a social media site, the state includes when a user logged in, what they did, where they were, etc. For an airplane or spaceship, the state includes current status of different parts of the ship, fuel or energy levels, temperature or atmospheric data, etc. As each individual actor in the network uses the consensus protocol to propagate the changes they're doing locally and update their own state based on updates they're getting from others, a historical understanding of the system begins to emerge from these state changes. This coordination of state among multiple actors in a common system allows for many interesting systems, including many of the digital services we use today. Please note that we're using terms like \"actors\" or \"participants\" to describe the active parties in a distributed system. Despite the name, these traditionally refer to machines or computers in a network more commonly called nodes . It can be confusing but just try to remember these are general models we're discussing. Once we get into application and practice, it may be easier to understand. A distributed system where multiple actors are using a consensus protocol to maintain state can be called a state machine or finite state machine. This is fairly technical, but it simply requires us to expand our understanding of a machine, which we typically think of as a metal box containing small electronics connected by circuits. \"State machine\" allows us to consider larger systems, such as a cellphone network or all the electronic parts comprising an airplane, as themselves being machines comprised of nodes consistently maintaining a global state among themselves without a central point of failure. Along with state, distributed consensus relies on a few concepts, such as: Nodes In a strict technical sense, a node is defined as \"an electronic device that is attached to a network, and is capable of creating, receiving, or transmitting information over a communication channel.\" Distributed systems are comprised of nodes. We also call nodes participants or actors. Nodes typically fall into three categories: Leaders (nodes responsible for proposing values), Acceptors (nodes that receive values from Leader and accept them), Processors (nodes that do some operations or processing on received values) ( source ). These roles are not exclusive, a single node may take on one, two, or all three roles. Message Propagation A node can update its state in a distributed network exclusively through messages. How those messages pass or propagate through the network is a critical part of maintaining state. If a node cannot pass a message through a network, there cannot be a unified state that all network nodes agree on. How nodes in a network propagate their messages is known as its topology. Centralized systems, as shown below, can quickly distribute messages. However, they aren't particularly resilient (if the single central node collapses, so does the network). As a result, distributed systems have developed their own peer-to-peer protocols. Below is a famous diagram showing centralized, decentralized and distributed network topologies: Time The notion of time is very important in a distributed system as it creates a sort of order for the larger system. Ordering events that occur in a system is particularly important. Think about making breakfast, for example. If you mix up the order of a series of actions, like eating your eggs before you cook them, it can create chaos and confusion. Here's an article from Dean Eigenmann discussing the concept of Time, Clocks, and Order in distributed systems. Periods Related to the idea of time, every consensus protocol requires discrete periods of activity. Perhaps a node is waiting to hear from a leader, perhaps a series of transactions are being prepared for a block, perhaps the nodes are passing around the latest agreed-upon state. These periods are critical to any consensus protocol. In blockchain systems, these periods typically revolve around the creation and propagation of transactions in a block. Fault Tolerance This is a formal description of resilience: How many mistakes can a system tolerate before it will collapse completely? Put another way, how many bad nodes can we have in a system before the system ceases to propagate state? Leslie Lamport proposed a subset of fault tolerance called Byzantine Fault Tolerance. We discussed it briefly in the video before. Essentially, the most amount of fault a distributed network can absorb is one-third. So, if 2/3rds of a system are still available and coordinating, the system can still run. Because of this famous thought experiment, you may see fault tolerance referred to as Byzantine Fault tolerance or Practical Byzantine Fault Tolerance. However, it's similar to how a rectangle is not a square but a square is a rectangle: Not all fault tolerance is Byzantine fault tolerance. We'll discuss more of this later in the section on trustless consensus. Please note: Distributed consensus outside of blockchain only deals with systems that are non-adversarial meaning all the nodes trust each other. This means the only errors that would show up would be from things like power failures or misbehaving parts, etc. You would not attribute malice to any misbehaving actor. Blockchain's big innovation, which we'll discuss later, was the creation of consensus protocols in adversarial networks in which you must assume everyone is out to get you. This is what we call trustless consensus . Conclusion In our search for the primitives underlying blockchain technology, consensus holds an important piece by allowing a network to have a memory of its own history, which we are calling state. We saw how cryptography allowed us to ensure peer-to-peer authenticity in the moment. Consensus protocols allow us to \"save\" that authenticity across time by facilitating the coordination of all network nodes around a global state. It also allows new participants (nodes) to enter the system and get \"up to date\" on what has happened previously in the system. The next section is an excellent overview of a basic consensus protocol system called Raft. Raft is a simplified consensus algorithm which we feel makes it more approachable to understand. However, Raft is a production-ready consensus protocol used by such major projects as MongoDB. The website The Secret Lives of Data has created an extraordinary walkthrough of Raft, which we hope will illustrate consensus in a concrete way. Additional Links ### Basic Interactive: Raft: Understandable Distributed Consensus A really excellent, interactive walkthrough of the Raft consensus protocol, a basic consensus protocol. The simple and easy way in which the tutorial walks through the consensus mechanism will help you understand how consensus protocols work on a practical level. Article: Let's Take a Crack at Understanding Distributed Consensus (Preethi Kasireddy) Article Series: Distributed Systems Digest (Dean Eigenmann) This is an excellent series of articles discussing distributed systems, in an approachable way. If you click \"Let me read it first,\" you can access the articles. Podcast: Distributed Systems with Ethan Buchman (Software Engineering Daily) An overview on distributed systems, including the history of their development Article: Want to Really Understand Blockchain? You Need to Understand State (ConsenSys) Article: A Brief Overview of Kademlia and Its Use In Various Decentralized Platforms The Kademlia protocol is a peer-to-peer file sharing system used by many decentralized systems, including Ethereum. Article: Nodes and Links (Explained from First Principles) Interactive Code: BitTorrent Simulator A very cool visualization of how files are distributed over BitTorrent, which uses peer-to-peer file sharing Wikipedia: Consensus Methods, Distributed Computing, Network Resilience, Fault Tolerance, Network State, Byzantine Fault Tolerance State Machines, Peer-to-Peer Protocols, Gossip Protocol ### Advanced Course: Distributed Systems Textbook: Foundations of Distributed Consensus and Blockchains (Elaine Shi) An advanced and extremely technical but comprehensive view on distributed consensus as it pertains to blockchain development. Academic Article: Leslie Lamport's Byzantine Generals Problem Article: Times, Clocks and Ordering (Leslie Lamport) GitHub: Notes for Dean Eigenmann's Article \"Times, Clocks and Ordering\" GitHub: P2P Workshops This site has a series of exercises to learn about building P2P networks","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L2-consensus-additional/#distributed-coordination-consensus-protocols","text":"After learning about cryptography, we know how to create an identity, how to make sure no one has messed with a file, and how to capture a user's intent all in a decentralized peer-to-peer way. This is all well and good for current interactions or things we are doing now on a network, but how do we agree on things that have happened in the past? That is, how do actors in a network we coordinate and agree on the series of events that have led to the current state of the network? How do we know someone really does have digital money they can send to us and are not making it up? How do all the actors in the network then maintain that knowledge in a secure way? This is what we're going to learn in this module. To understand how all the actors in a network can coordinate and agree about the historical state of a blockchain network we will learn about consensus . Distributed consensus is not only used in blockchain, to be clear. Any internet service that needs to coordinate their servers all over the globe (which is all the major internet services) uses distributed consensus mechanisms to make that happen. Blockchain takes traditional distributed consensus one step further. We'll see what that step is once we understand the historical and fundamental principles of distributed computing. (Note: In this section, we will use the terms Distributed Computing , Distributed Systems , Distributed Consensus , and Distributed Coordination interchangeably. We'll also be speaking about consensus strictly in the computer scientific sense. Later in the course, we'll discuss consensus among people in a network, typically called governance .)","title":"Distributed Coordination: Consensus Protocols"},{"location":"S01-fundamentals/M3-consensus/L2-consensus-additional/#development-of-distributed-computing","text":"Distributed Computing became an important field of study in the 1970s when airplanes started using electronic control systems. Airline manufacturers wanted to make sure that if a certain part of the electronics gave out while the plane was in the air, the whole plane wouldn't shut down. In the scenario of an airplane, the \"bad actor\" is not a hacker trying to purposefully disable the entire airplane, but rather a single part that is not behaving as it should. As a result, researchers began researching and developing consensus protocols for the airplane computer systems. At the most basic level, \"consensus protocols are used to allow computers to work together\" and \"let different servers agree on the state of a system.\" ( Software Engineering Daily ). For the airplane manufacturers, a good consensus protocol would continue to function with some errors. This way, if one or two things failed, the entire system wouldn't fail. The ability of a consensus protocol to adapt to failure is called resilience. Crucially, early work around distributed computing and consensus protocols dealt with non-adversarial systems . This meant that any of the faults that were happening in a computer network, like an airplane, were the result of natural system errors (power failure, faulty parts, etc), not some sort of active meddling or hacking. This has now developed to encompass much more than aerospace technology. As we mentioned before, it now also covers many digital services, such as: * Any multi-party real-time communication stream (like a social media feed) * An online media streaming service which requires multiple regional servers holding and updating the exact same information on customers * A search engine service that needs to maintain and update indexed information across many regions Consensus protocols help these systems maintain historical information also called state. Broadly speaking, state can be defined as a set of variables describing a certain system at a specific time. Let\u2019s describe that in a real-world situation. Take a look around at whatever environment you\u2019re in\u2013\u2013bus station, coffee shop, office\u2013\u2013and pick out a few variables you could use to describe it. If you\u2019re inside a room, you could describe any number of things: * The number of walls * The types of furniture * The placement of furniture * The number of people * The kind of light in the room Taken all together, these variables will paint a picture of the room. And if things change (say, you turn off a light), we'll update \"The kind of light in the room\" variable, which changes the state. If multiple people needed to maintain a record about the state of our room, we'd have to find a way to communicate this state change. Consensus protocols help us do exactly that: agree on a sequential series of system state which allows all network participants adhering to the consensus protocol to have a similar understanding of the historical changes adding up to the current network state. For a distributed computer network, state typically involves technical information about critical actors in a system. For a social media site, the state includes when a user logged in, what they did, where they were, etc. For an airplane or spaceship, the state includes current status of different parts of the ship, fuel or energy levels, temperature or atmospheric data, etc. As each individual actor in the network uses the consensus protocol to propagate the changes they're doing locally and update their own state based on updates they're getting from others, a historical understanding of the system begins to emerge from these state changes. This coordination of state among multiple actors in a common system allows for many interesting systems, including many of the digital services we use today. Please note that we're using terms like \"actors\" or \"participants\" to describe the active parties in a distributed system. Despite the name, these traditionally refer to machines or computers in a network more commonly called nodes . It can be confusing but just try to remember these are general models we're discussing. Once we get into application and practice, it may be easier to understand. A distributed system where multiple actors are using a consensus protocol to maintain state can be called a state machine or finite state machine. This is fairly technical, but it simply requires us to expand our understanding of a machine, which we typically think of as a metal box containing small electronics connected by circuits. \"State machine\" allows us to consider larger systems, such as a cellphone network or all the electronic parts comprising an airplane, as themselves being machines comprised of nodes consistently maintaining a global state among themselves without a central point of failure. Along with state, distributed consensus relies on a few concepts, such as: Nodes In a strict technical sense, a node is defined as \"an electronic device that is attached to a network, and is capable of creating, receiving, or transmitting information over a communication channel.\" Distributed systems are comprised of nodes. We also call nodes participants or actors. Nodes typically fall into three categories: Leaders (nodes responsible for proposing values), Acceptors (nodes that receive values from Leader and accept them), Processors (nodes that do some operations or processing on received values) ( source ). These roles are not exclusive, a single node may take on one, two, or all three roles. Message Propagation A node can update its state in a distributed network exclusively through messages. How those messages pass or propagate through the network is a critical part of maintaining state. If a node cannot pass a message through a network, there cannot be a unified state that all network nodes agree on. How nodes in a network propagate their messages is known as its topology. Centralized systems, as shown below, can quickly distribute messages. However, they aren't particularly resilient (if the single central node collapses, so does the network). As a result, distributed systems have developed their own peer-to-peer protocols. Below is a famous diagram showing centralized, decentralized and distributed network topologies: Time The notion of time is very important in a distributed system as it creates a sort of order for the larger system. Ordering events that occur in a system is particularly important. Think about making breakfast, for example. If you mix up the order of a series of actions, like eating your eggs before you cook them, it can create chaos and confusion. Here's an article from Dean Eigenmann discussing the concept of Time, Clocks, and Order in distributed systems. Periods Related to the idea of time, every consensus protocol requires discrete periods of activity. Perhaps a node is waiting to hear from a leader, perhaps a series of transactions are being prepared for a block, perhaps the nodes are passing around the latest agreed-upon state. These periods are critical to any consensus protocol. In blockchain systems, these periods typically revolve around the creation and propagation of transactions in a block. Fault Tolerance This is a formal description of resilience: How many mistakes can a system tolerate before it will collapse completely? Put another way, how many bad nodes can we have in a system before the system ceases to propagate state? Leslie Lamport proposed a subset of fault tolerance called Byzantine Fault Tolerance. We discussed it briefly in the video before. Essentially, the most amount of fault a distributed network can absorb is one-third. So, if 2/3rds of a system are still available and coordinating, the system can still run. Because of this famous thought experiment, you may see fault tolerance referred to as Byzantine Fault tolerance or Practical Byzantine Fault Tolerance. However, it's similar to how a rectangle is not a square but a square is a rectangle: Not all fault tolerance is Byzantine fault tolerance. We'll discuss more of this later in the section on trustless consensus. Please note: Distributed consensus outside of blockchain only deals with systems that are non-adversarial meaning all the nodes trust each other. This means the only errors that would show up would be from things like power failures or misbehaving parts, etc. You would not attribute malice to any misbehaving actor. Blockchain's big innovation, which we'll discuss later, was the creation of consensus protocols in adversarial networks in which you must assume everyone is out to get you. This is what we call trustless consensus .","title":"Development of Distributed Computing"},{"location":"S01-fundamentals/M3-consensus/L2-consensus-additional/#conclusion","text":"In our search for the primitives underlying blockchain technology, consensus holds an important piece by allowing a network to have a memory of its own history, which we are calling state. We saw how cryptography allowed us to ensure peer-to-peer authenticity in the moment. Consensus protocols allow us to \"save\" that authenticity across time by facilitating the coordination of all network nodes around a global state. It also allows new participants (nodes) to enter the system and get \"up to date\" on what has happened previously in the system. The next section is an excellent overview of a basic consensus protocol system called Raft. Raft is a simplified consensus algorithm which we feel makes it more approachable to understand. However, Raft is a production-ready consensus protocol used by such major projects as MongoDB. The website The Secret Lives of Data has created an extraordinary walkthrough of Raft, which we hope will illustrate consensus in a concrete way.","title":"Conclusion"},{"location":"S01-fundamentals/M3-consensus/L2-consensus-additional/#additional-links","text":"### Basic Interactive: Raft: Understandable Distributed Consensus A really excellent, interactive walkthrough of the Raft consensus protocol, a basic consensus protocol. The simple and easy way in which the tutorial walks through the consensus mechanism will help you understand how consensus protocols work on a practical level. Article: Let's Take a Crack at Understanding Distributed Consensus (Preethi Kasireddy) Article Series: Distributed Systems Digest (Dean Eigenmann) This is an excellent series of articles discussing distributed systems, in an approachable way. If you click \"Let me read it first,\" you can access the articles. Podcast: Distributed Systems with Ethan Buchman (Software Engineering Daily) An overview on distributed systems, including the history of their development Article: Want to Really Understand Blockchain? You Need to Understand State (ConsenSys) Article: A Brief Overview of Kademlia and Its Use In Various Decentralized Platforms The Kademlia protocol is a peer-to-peer file sharing system used by many decentralized systems, including Ethereum. Article: Nodes and Links (Explained from First Principles) Interactive Code: BitTorrent Simulator A very cool visualization of how files are distributed over BitTorrent, which uses peer-to-peer file sharing Wikipedia: Consensus Methods, Distributed Computing, Network Resilience, Fault Tolerance, Network State, Byzantine Fault Tolerance State Machines, Peer-to-Peer Protocols, Gossip Protocol ### Advanced Course: Distributed Systems Textbook: Foundations of Distributed Consensus and Blockchains (Elaine Shi) An advanced and extremely technical but comprehensive view on distributed consensus as it pertains to blockchain development. Academic Article: Leslie Lamport's Byzantine Generals Problem Article: Times, Clocks and Ordering (Leslie Lamport) GitHub: Notes for Dean Eigenmann's Article \"Times, Clocks and Ordering\" GitHub: P2P Workshops This site has a series of exercises to learn about building P2P networks","title":"Additional Links"},{"location":"S01-fundamentals/M3-consensus/L3-raft/","text":"Raft Consensus Tutorial Please go to the Secret Lives of Data website to learn about the basic mechanics of the Raft consensus protocol. While Raft is a production-ready consensus protocol, we are mainly using it here to show you a concrete example of a distributed system maintaining state across different nodes in a network. Please note, Raft is not a Byzantine fault tolerant consensus protocol. Instead, Raft is a leader-led consensus protocol, meaning all the nodes blindly trust whatever state the leader sends to them. However, in Raft, if the leader fails in some way and stops sending state, the other nodes in the network are able to identify the failure and re-elect another leader in a distributed way. In this way, the Raft consensus mechanism shows how a distributed system can replicate state in a resilient way. Even if you never see it or use it again, we hope learning about Raft will give you a better sense of how a distributed system can use a consensus protocol to adapt to node failures. Additional Resources Wikipedia: Raft Article: In Search of an Understandable Consensus Algorithm The Raft consensus protocol was developed as a simpler alternative to the Paxos consensus algorithm developed by Leslie Lamport.","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L3-raft/#raft-consensus-tutorial","text":"Please go to the Secret Lives of Data website to learn about the basic mechanics of the Raft consensus protocol. While Raft is a production-ready consensus protocol, we are mainly using it here to show you a concrete example of a distributed system maintaining state across different nodes in a network. Please note, Raft is not a Byzantine fault tolerant consensus protocol. Instead, Raft is a leader-led consensus protocol, meaning all the nodes blindly trust whatever state the leader sends to them. However, in Raft, if the leader fails in some way and stops sending state, the other nodes in the network are able to identify the failure and re-elect another leader in a distributed way. In this way, the Raft consensus mechanism shows how a distributed system can replicate state in a resilient way. Even if you never see it or use it again, we hope learning about Raft will give you a better sense of how a distributed system can use a consensus protocol to adapt to node failures.","title":"Raft Consensus Tutorial"},{"location":"S01-fundamentals/M3-consensus/L3-raft/#additional-resources","text":"Wikipedia: Raft Article: In Search of an Understandable Consensus Algorithm The Raft consensus protocol was developed as a simpler alternative to the Paxos consensus algorithm developed by Leslie Lamport.","title":"Additional Resources"},{"location":"S01-fundamentals/M3-consensus/L4-trustless-consensus/","text":"Trustless Consensus We've spent the past few sections learning about how consensus protocols work to make peer-to-peer distributed systems maintain state across time despite node failure. This is a general computer science concept that's used in building distributed networks that may be susceptible to machine failures, message duplications, message corruptions, etc. Since they are decentralized networks, public blockchains have to deal with this category of problems. But, they are also presented with an entirely new set of issues. Public blockchains introduce a specific challenge to agreeing on a state. In a non-blockchain distributed network, state is a set of data valuable really only to the private organization running the network. For example, in a digital streaming service, the state might contain where a user stopped watching a previous video. That way, if they start the video again and are served the content from a different network server, their place will be saved. The state of a public blockchain network, on the other hand, is the public, distributed ledger which contains the financial balances of everyone in the network. This has enormous value to many different organizations and individuals. In a way, everyone is incentivized to lie about the state of the network because it's directly tied to their net worth. Imagine if when you went to the bank, rather than a bank teller telling you your balance, they asked you for your balance. Most people would, at some point, be very tempted to lie and make up a number (Probably a very large number). This is the main element that distinguishes public blockchain networks from traditional distributed networks. The network state of a blockchain is one that contains economic value directly impacting the actors in the network. But, as we've seen studying traditional distributed systems, the blockchain network still needs those nodes (which have competing interests) to update and propagate the state. Enter trustless consensus: Bitcoin solves this issue by creating a consensus mechanism which can operate in an adversarial environment where the nodes have competing interests. Rather than assuming the state they are propagating is correct, Bitcoin's trustless consensus allows each individual node to verify the state themselves using cryptography. We'll walk through how Bitcoin and other proof of work blockchain networks achieve this feat by describing the underlying assumptions and the solutions. Quick aside: What about current traditional banks? Don't they have distributed networks that contain economic value among nodes (customers) with competing interests? Why don't we consider them as solving this issue? Yes, this is true that global financial companies or governments have built distributed networks that have similar conditions to what public blockchains are hoping to achieve. However, these traditional networks separate trust from distributed consensus in their networks. You can imagine it like a castle, with powerful fortifications, that contains a ledger containing all the assets in the kingdom. If you can breach the defenses and get into the castle, you'll have control over that ledger. Blockchain's theoretical innovation is baking the defense into the consensus mechanisms themselves so there are many different castles and, if one falls, it may temporarily impact the network but will not collapse the system. In fact, because blockchains are removing trusted intermediaries (like a bank) the only way to make their network state secure is to assume that everyone is lying. With your trust assumptions low (assuming everyone is lying), you're protected against that behavior. How do you create a consensus protocol in these dire circumstances? Well, this is the incredible innovation that blockchains, beginning with Bitcoin, created. It not only built the ecosystem of blockchain networks we see in today's world, but it even solved a general distributed computing problem in the process. Double Spend and Byzantine Generals Solution The biggest issue facing digital money is what is called the \"double spend\" problem: Since digital files can be copied endlessly, how can you be sure whatever digital money you're paid with has not been previously spent? This is the critical issue Satoshi Nakamoto set out to solve in the Bitcoin whitepaper : We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. Nakamoto Consensus, also called Proof of Work consensus, creates a consensus mechanism for a digital money system where each individual node does not have to blindly accept the network state. Elements of Proof of Work Consensus In discussing the elements comprising Proof of Work consensus, we'll pull from concepts we mentioned previously in our discussion of traditionally distributed networks. Specifically, you'll need to remember the concept of messages , the concept of nodes and the roles they play as well as the concept of time and periods in distributed systems. ### Messages In Proof of Work consensus, the fundamental message is a transaction, constructed using the public key cryptography and digital signatures primitives we discussed previously, \"trustlessly\" (cryptographically) ensuring the identity and integrity of the message. Transactions in Proof of Work consensus are atomic, meaning the network either accepts or rejects the transaction, there is no in-between or halfway. If the network accepts the transaction, the network state then advances to incorporate the effects of the transaction. For example, let's say an imaginary public ledger at State-0 says Alejandro has 1 token and Barbarella has 0 tokens . Alejandro then submits a transaction to the network saying he would like to pay Barbarella 0.5 tokens . The network accepts the transaction, which creates a new state, State-1 in which the public ledger has been updated to show Alejandro now has 0.5 tokens and Barbarella has 0.5 tokens . ### Nodes and their Roles In Proof of Work consensus, here are the roles nodes play: * Miners These are the nodes which are certifying which transactions are valid by including them in blocks and receiving the block reward. When a miner creates a valid block and propagates it throughout the network, the network state is advanced in a trustless way. (We'll examine in a moment how a miner can create a block in a trustless way.) * Full Nodes These are the general network nodes which are creating transactions and passing along transactions created by other nodes in the network. They are also maintaining full network state when they receive valid blocks from Miner nodes. Each full node in the network checks the work of a block to ensure its validity. * Light Nodes These are network nodes which are simply submitting transactions to the network and waiting for them to be accepted by the network. They do not participate in the process of checking the validity of the advancing network state and do not pass along messages. * Archive Nodes Similar to a full node, it maintains and provides the current state, but also maintains and provides historical states. e.g. balance at x date. Remember from the section on public key cryptography that nodes identify themselves in the network by using the peer-to-peer identity mechanism of public key cryptography. ### Periods and Proof of Work In Proof of Work consensus, there are two distinct periods in a network: * Period of Block Production This is the period in which Miner nodes validate transactions by bundling them all together and competing to produce a valid Proof of Work algorithm. It begins when the miner receives the latest valid block and stops when the miner solves their Proof of Work algorithm or receives a valid block from another miner. * Period of Block Propagation This is the period in which a valid block gradually moves through the network. A full node or miner node will only propagate blocks that are valid, so the process of the network accepting a valid block (and accepted the new network state) is an emergent one. The following section will describe the process of creating a block and how blocks chained together create an immutable ledger that all network participants can validate on their own. This individual validation, without having to rely on trust, is how proof of work consensus maintains state in a distributed and safe way. Additional Materials ### Introduction [Ethereum Node Types * Video & Interactive Code: ETH.Build with Byzantine Generals' Problem Austin Griffith walks through a hands-on implementation of the Byzantine Generals' Problem with his amazing ETH.Build platform Article: What is the Byzantine Generals Problem? Interactive Code: Anders Blockchain A great, web-based interactive tutorial going over fundamentals of Proof of Work consensus including block production through hashing and distributed blockchains Article: How Satoshi Nakamoto Solved the Byzantine Generals Problem Wikipedia: Directed Acyclic Graphs Because each new block embeds the hash of the previous valid block, this creates a computer science data structure known as Directed Acyclic Graphs (similar to the way Git software works!).](https://ethereum.org/en/developers/docs/nodes-and-clients/#) ### Advanced Code: Implementing Proof of Work A continuation of the series from Kyle Simpson Code: Implementing Mining Protocol A continuation of the series from Kyle Simpson","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L4-trustless-consensus/#trustless-consensus","text":"We've spent the past few sections learning about how consensus protocols work to make peer-to-peer distributed systems maintain state across time despite node failure. This is a general computer science concept that's used in building distributed networks that may be susceptible to machine failures, message duplications, message corruptions, etc. Since they are decentralized networks, public blockchains have to deal with this category of problems. But, they are also presented with an entirely new set of issues. Public blockchains introduce a specific challenge to agreeing on a state. In a non-blockchain distributed network, state is a set of data valuable really only to the private organization running the network. For example, in a digital streaming service, the state might contain where a user stopped watching a previous video. That way, if they start the video again and are served the content from a different network server, their place will be saved. The state of a public blockchain network, on the other hand, is the public, distributed ledger which contains the financial balances of everyone in the network. This has enormous value to many different organizations and individuals. In a way, everyone is incentivized to lie about the state of the network because it's directly tied to their net worth. Imagine if when you went to the bank, rather than a bank teller telling you your balance, they asked you for your balance. Most people would, at some point, be very tempted to lie and make up a number (Probably a very large number). This is the main element that distinguishes public blockchain networks from traditional distributed networks. The network state of a blockchain is one that contains economic value directly impacting the actors in the network. But, as we've seen studying traditional distributed systems, the blockchain network still needs those nodes (which have competing interests) to update and propagate the state. Enter trustless consensus: Bitcoin solves this issue by creating a consensus mechanism which can operate in an adversarial environment where the nodes have competing interests. Rather than assuming the state they are propagating is correct, Bitcoin's trustless consensus allows each individual node to verify the state themselves using cryptography. We'll walk through how Bitcoin and other proof of work blockchain networks achieve this feat by describing the underlying assumptions and the solutions. Quick aside: What about current traditional banks? Don't they have distributed networks that contain economic value among nodes (customers) with competing interests? Why don't we consider them as solving this issue? Yes, this is true that global financial companies or governments have built distributed networks that have similar conditions to what public blockchains are hoping to achieve. However, these traditional networks separate trust from distributed consensus in their networks. You can imagine it like a castle, with powerful fortifications, that contains a ledger containing all the assets in the kingdom. If you can breach the defenses and get into the castle, you'll have control over that ledger. Blockchain's theoretical innovation is baking the defense into the consensus mechanisms themselves so there are many different castles and, if one falls, it may temporarily impact the network but will not collapse the system. In fact, because blockchains are removing trusted intermediaries (like a bank) the only way to make their network state secure is to assume that everyone is lying. With your trust assumptions low (assuming everyone is lying), you're protected against that behavior. How do you create a consensus protocol in these dire circumstances? Well, this is the incredible innovation that blockchains, beginning with Bitcoin, created. It not only built the ecosystem of blockchain networks we see in today's world, but it even solved a general distributed computing problem in the process.","title":"Trustless Consensus"},{"location":"S01-fundamentals/M3-consensus/L4-trustless-consensus/#double-spend-and-byzantine-generals-solution","text":"The biggest issue facing digital money is what is called the \"double spend\" problem: Since digital files can be copied endlessly, how can you be sure whatever digital money you're paid with has not been previously spent? This is the critical issue Satoshi Nakamoto set out to solve in the Bitcoin whitepaper : We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. Nakamoto Consensus, also called Proof of Work consensus, creates a consensus mechanism for a digital money system where each individual node does not have to blindly accept the network state.","title":"Double Spend and Byzantine Generals Solution"},{"location":"S01-fundamentals/M3-consensus/L4-trustless-consensus/#elements-of-proof-of-work-consensus","text":"In discussing the elements comprising Proof of Work consensus, we'll pull from concepts we mentioned previously in our discussion of traditionally distributed networks. Specifically, you'll need to remember the concept of messages , the concept of nodes and the roles they play as well as the concept of time and periods in distributed systems. ### Messages In Proof of Work consensus, the fundamental message is a transaction, constructed using the public key cryptography and digital signatures primitives we discussed previously, \"trustlessly\" (cryptographically) ensuring the identity and integrity of the message. Transactions in Proof of Work consensus are atomic, meaning the network either accepts or rejects the transaction, there is no in-between or halfway. If the network accepts the transaction, the network state then advances to incorporate the effects of the transaction. For example, let's say an imaginary public ledger at State-0 says Alejandro has 1 token and Barbarella has 0 tokens . Alejandro then submits a transaction to the network saying he would like to pay Barbarella 0.5 tokens . The network accepts the transaction, which creates a new state, State-1 in which the public ledger has been updated to show Alejandro now has 0.5 tokens and Barbarella has 0.5 tokens . ### Nodes and their Roles In Proof of Work consensus, here are the roles nodes play: * Miners These are the nodes which are certifying which transactions are valid by including them in blocks and receiving the block reward. When a miner creates a valid block and propagates it throughout the network, the network state is advanced in a trustless way. (We'll examine in a moment how a miner can create a block in a trustless way.) * Full Nodes These are the general network nodes which are creating transactions and passing along transactions created by other nodes in the network. They are also maintaining full network state when they receive valid blocks from Miner nodes. Each full node in the network checks the work of a block to ensure its validity. * Light Nodes These are network nodes which are simply submitting transactions to the network and waiting for them to be accepted by the network. They do not participate in the process of checking the validity of the advancing network state and do not pass along messages. * Archive Nodes Similar to a full node, it maintains and provides the current state, but also maintains and provides historical states. e.g. balance at x date. Remember from the section on public key cryptography that nodes identify themselves in the network by using the peer-to-peer identity mechanism of public key cryptography. ### Periods and Proof of Work In Proof of Work consensus, there are two distinct periods in a network: * Period of Block Production This is the period in which Miner nodes validate transactions by bundling them all together and competing to produce a valid Proof of Work algorithm. It begins when the miner receives the latest valid block and stops when the miner solves their Proof of Work algorithm or receives a valid block from another miner. * Period of Block Propagation This is the period in which a valid block gradually moves through the network. A full node or miner node will only propagate blocks that are valid, so the process of the network accepting a valid block (and accepted the new network state) is an emergent one. The following section will describe the process of creating a block and how blocks chained together create an immutable ledger that all network participants can validate on their own. This individual validation, without having to rely on trust, is how proof of work consensus maintains state in a distributed and safe way.","title":"Elements of Proof of Work Consensus"},{"location":"S01-fundamentals/M3-consensus/L4-trustless-consensus/#additional-materials","text":"### Introduction [Ethereum Node Types * Video & Interactive Code: ETH.Build with Byzantine Generals' Problem Austin Griffith walks through a hands-on implementation of the Byzantine Generals' Problem with his amazing ETH.Build platform Article: What is the Byzantine Generals Problem? Interactive Code: Anders Blockchain A great, web-based interactive tutorial going over fundamentals of Proof of Work consensus including block production through hashing and distributed blockchains Article: How Satoshi Nakamoto Solved the Byzantine Generals Problem Wikipedia: Directed Acyclic Graphs Because each new block embeds the hash of the previous valid block, this creates a computer science data structure known as Directed Acyclic Graphs (similar to the way Git software works!).](https://ethereum.org/en/developers/docs/nodes-and-clients/#) ### Advanced Code: Implementing Proof of Work A continuation of the series from Kyle Simpson Code: Implementing Mining Protocol A continuation of the series from Kyle Simpson","title":"Additional Materials"},{"location":"S01-fundamentals/M3-consensus/L5-what-is-a-block/","text":"What is a Block? Now that we've gone over trustless consensus, this video will offer an explanation of how a block becomes valid in the network https://streamable.com/zip8cb","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L5-what-is-a-block/#what-is-a-block","text":"Now that we've gone over trustless consensus, this video will offer an explanation of how a block becomes valid in the network https://streamable.com/zip8cb","title":"What is a Block?"},{"location":"S01-fundamentals/M3-consensus/L6-chain-of-blocks/","text":"A Chain of Blocks This video will offer an explanation of how a chain of blocks builds on its own security. https://streamable.com/obw7ps","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L6-chain-of-blocks/#a-chain-of-blocks","text":"This video will offer an explanation of how a chain of blocks builds on its own security. https://streamable.com/obw7ps","title":"A Chain of Blocks"},{"location":"S01-fundamentals/M3-consensus/L7-pow-in-ethereum/","text":"Proof of Work in Ethereum This video offers another explanation of Proof of Work mining, this time in Ethereum, while also discussing about the Period of Block Propagation, also called \"Heaviest Chain\" selection, which allows for the state transitions confirmed by valid blocks to move through the network. https://streamable.com/dyhdst","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L7-pow-in-ethereum/#proof-of-work-in-ethereum","text":"This video offers another explanation of Proof of Work mining, this time in Ethereum, while also discussing about the Period of Block Propagation, also called \"Heaviest Chain\" selection, which allows for the state transitions confirmed by valid blocks to move through the network. https://streamable.com/dyhdst","title":"Proof of Work in Ethereum"},{"location":"S01-fundamentals/M3-consensus/L8-blockchain-fork/","text":"What is a Blockchain Fork? Forks occur in many consensus-governed computer networks but are especially impactful on blockchains. This video will walk you through some of the consequences of forks in the context of trustless consensus and blockchains. https://streamable.com/02rpw8","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L8-blockchain-fork/#what-is-a-blockchain-fork","text":"Forks occur in many consensus-governed computer networks but are especially impactful on blockchains. This video will walk you through some of the consequences of forks in the context of trustless consensus and blockchains. https://streamable.com/02rpw8","title":"What is a Blockchain Fork?"},{"location":"S01-fundamentals/M3-consensus/L9-alt-consensus/","text":"More Forms of Consensus We've spoken mainly about Proof of Work, since it's the current consensus mechanism for Bitcoin and Ethereum, as well as other blockchains. However, there are other consensus protocols being used by blockchain networks, such as: * Proof of Stake A consensus protocol based on financial holdings of validator nodes in the network (similar to miner nodes in Proof of Work). Proof of Stake requires much less energy to run than Proof of Work and, for this reason, Ethereum is currently working towards this consensus mechanism. * Delegated Proof of Stake This is a variant of the Proof of Stake protocol in which stakeholders can elect validators to represent them in the system. * Proof of Authority This is a more traditional consensus mechanism like Raft's leader-led consensus in which only certain nodes are allowed to produce blocks at their discretion. It's meant for smaller, perhaps private networks where the participants all know each other or for lower-stake networks such as testnets or networks securing trivial amounts of value. Why would we need another consensus mechanism for blockchains, if Proof of Work is so innovative? A few reasons: * Accessibility The barriers to entry to becoming a PoW miner are high. Proof of Work chains require a substantial amount of energy to maintain. A miner must purchase, set up, and maintain all the necessary hardware to run a PoW mining rig. Additionally, PoW mining is extremely energy-intensive. * Centralization Barriers to entry for mining can have the adverse secondary effect of greater centralization of miners. As it gets more costly and less profitable to become a miner, the network naturally sees a concentration of mining into two categories. First, large mining conglomerates that operate in areas with low electricity costs and cold weather (to reduce the cost of manually cooling mining hardware) such as Mongolia and Siberia. Second, mining power is centralized in the hands of mining pools. As it becomes less profitable for most people to mine individually, they buy hash power from a mining pool, which operates as a single mining entity. By the end of 2019, over 50% of blocks on Ethereum were mined by just two mining pools. Proof of Stake Proof of Stake is a different kind of consensus mechanism blockchains can use to agree upon a single true record of data history. Whereas in Proof of Work miners expend energy (electricity) to mine blocks into existence, in Proof of Stake validators commit stake to attest (or \u2018validate\u2019) blocks into existence. Validators are the participants on the network who run nodes (called validator nodes ) to propose and attest blocks on a Proof of Stake network. They do so by staking crypto on the network and make themselves available to be randomly selected to propose a block. Other validators then \u201cattest\u201d that they have seen the block. When a sufficient number of attestations for the block has been collected, the block is added to the blockchain. Validators receive rewards both for successfully proposing blocks (just as they do in Proof of Work) and for making attestations about blocks that they have seen. The crypto-economic incentives for Proof of Stake are designed to create more compelling rewards for proper behavior and more severe penalties for malicious behavior. The core crypto-economic incentive boils down to the requirement that validators stake their own crypto\u2013\u2013i.e. money\u2013\u2013on the network. Instead of considering the secondary cost of electricity to run a Proof of Work node, validators on Proof of Stake chains are forced to directly deposit a significant monetary amount onto the network. Validators accrue rewards for making blocks and attestations when it is their turn to do so. They are penalized for not following through with their responsibilities when it is their turn to do so \u2013 i.e. if they are offline. Penalties for being offline are relatively mild and equate to about the same as the expected rewards over time. So, if a validator is participating correctly more than half the time then her rewards will be net positive. Should a validator attempt to attack or compromise the blockchain by trying to propose a new set of data history, however, a different penalty mechanism kicks in: a substantial portion of their staked amount will be slashed (possibly up to the whole amount of stake) and they will be ejected from the network. The result is a tremendous financial risk of a failed attack by a validator. To draw an analogy to Proof of Work, it would be as if a miner who failed an attack on a PoW chain was forced to burn down her entire mining rig instead of just eating the cost of the electricity she spent on a failed attack. Furthermore, this architecture places the security of the network directly in the hands of those maintaining the network and holding its native crypto-asset in the protocol itself. Proof of Stake is used most notably in Ethereum 2.0 (more on that later) and other blockchain networks such as Cardano , EOS and PolkaDot . It's also used in Layer 2 solutions such as Polygon Proof of Stake It's important to note that a blockchain network does not have to use Proof of Work in their consensus mechanism. Bitcoin and Ethereum currently use it, but that does not mean it's the only game on the block! Additional Material Wiki: Consensus Mechanisms (Ethereum.org) Article: What is Proof of Stake (ConsenSys)","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L9-alt-consensus/#more-forms-of-consensus","text":"We've spoken mainly about Proof of Work, since it's the current consensus mechanism for Bitcoin and Ethereum, as well as other blockchains. However, there are other consensus protocols being used by blockchain networks, such as: * Proof of Stake A consensus protocol based on financial holdings of validator nodes in the network (similar to miner nodes in Proof of Work). Proof of Stake requires much less energy to run than Proof of Work and, for this reason, Ethereum is currently working towards this consensus mechanism. * Delegated Proof of Stake This is a variant of the Proof of Stake protocol in which stakeholders can elect validators to represent them in the system. * Proof of Authority This is a more traditional consensus mechanism like Raft's leader-led consensus in which only certain nodes are allowed to produce blocks at their discretion. It's meant for smaller, perhaps private networks where the participants all know each other or for lower-stake networks such as testnets or networks securing trivial amounts of value. Why would we need another consensus mechanism for blockchains, if Proof of Work is so innovative? A few reasons: * Accessibility The barriers to entry to becoming a PoW miner are high. Proof of Work chains require a substantial amount of energy to maintain. A miner must purchase, set up, and maintain all the necessary hardware to run a PoW mining rig. Additionally, PoW mining is extremely energy-intensive. * Centralization Barriers to entry for mining can have the adverse secondary effect of greater centralization of miners. As it gets more costly and less profitable to become a miner, the network naturally sees a concentration of mining into two categories. First, large mining conglomerates that operate in areas with low electricity costs and cold weather (to reduce the cost of manually cooling mining hardware) such as Mongolia and Siberia. Second, mining power is centralized in the hands of mining pools. As it becomes less profitable for most people to mine individually, they buy hash power from a mining pool, which operates as a single mining entity. By the end of 2019, over 50% of blocks on Ethereum were mined by just two mining pools.","title":"More Forms of Consensus"},{"location":"S01-fundamentals/M3-consensus/L9-alt-consensus/#proof-of-stake","text":"Proof of Stake is a different kind of consensus mechanism blockchains can use to agree upon a single true record of data history. Whereas in Proof of Work miners expend energy (electricity) to mine blocks into existence, in Proof of Stake validators commit stake to attest (or \u2018validate\u2019) blocks into existence. Validators are the participants on the network who run nodes (called validator nodes ) to propose and attest blocks on a Proof of Stake network. They do so by staking crypto on the network and make themselves available to be randomly selected to propose a block. Other validators then \u201cattest\u201d that they have seen the block. When a sufficient number of attestations for the block has been collected, the block is added to the blockchain. Validators receive rewards both for successfully proposing blocks (just as they do in Proof of Work) and for making attestations about blocks that they have seen. The crypto-economic incentives for Proof of Stake are designed to create more compelling rewards for proper behavior and more severe penalties for malicious behavior. The core crypto-economic incentive boils down to the requirement that validators stake their own crypto\u2013\u2013i.e. money\u2013\u2013on the network. Instead of considering the secondary cost of electricity to run a Proof of Work node, validators on Proof of Stake chains are forced to directly deposit a significant monetary amount onto the network. Validators accrue rewards for making blocks and attestations when it is their turn to do so. They are penalized for not following through with their responsibilities when it is their turn to do so \u2013 i.e. if they are offline. Penalties for being offline are relatively mild and equate to about the same as the expected rewards over time. So, if a validator is participating correctly more than half the time then her rewards will be net positive. Should a validator attempt to attack or compromise the blockchain by trying to propose a new set of data history, however, a different penalty mechanism kicks in: a substantial portion of their staked amount will be slashed (possibly up to the whole amount of stake) and they will be ejected from the network. The result is a tremendous financial risk of a failed attack by a validator. To draw an analogy to Proof of Work, it would be as if a miner who failed an attack on a PoW chain was forced to burn down her entire mining rig instead of just eating the cost of the electricity she spent on a failed attack. Furthermore, this architecture places the security of the network directly in the hands of those maintaining the network and holding its native crypto-asset in the protocol itself. Proof of Stake is used most notably in Ethereum 2.0 (more on that later) and other blockchain networks such as Cardano , EOS and PolkaDot . It's also used in Layer 2 solutions such as Polygon Proof of Stake It's important to note that a blockchain network does not have to use Proof of Work in their consensus mechanism. Bitcoin and Ethereum currently use it, but that does not mean it's the only game on the block!","title":"Proof of Stake"},{"location":"S01-fundamentals/M3-consensus/L9-alt-consensus/#additional-material","text":"Wiki: Consensus Mechanisms (Ethereum.org) Article: What is Proof of Stake (ConsenSys)","title":"Additional Material"},{"location":"S01-fundamentals/M3-consensus/L9a-consensus-conclusion/","text":"Consensus Conclusion Hopefully by now you feel like you have a sense of how distributed consensus works in a traditional network and how blockchains have innovated consensus protocols. While cryptographic primitives allow blockchain users to secure and validate current transactions, blockchain consensus protocols allow for a blockchain network to maintain a public ledger (the global state of the blockchain) in a decentralized way. Challenges of Consensus in Distributed Networks While blockchain consensus protocols have made great strides in decentralized networks, there are still some unsolved issues they're facing. Some of these (like the CAP theorem and forks) affect all general distributed networks while others, like Miner Extracted Value and 51% attacks, are specific to public blockchains. Here's a sampling and brief description of these challenges. Forks As we mentioned in a previous section, Proof of Work and other blockchain consensus mechanisms can lead to network forks (Note: In general computing networking, forks are also called partitions ). Some of these forks are voluntary (such as network upgrades), accidental (a node receives two valid but different new blocks) or adversarial (network participants purposefully breakaway from the main network to create a separate chain). While forks are common in all distributed systems, with blockchain networks they can be particuarly painful but are also necessary update mechanisms. Network Size The Scalability Trilemma details the different elements a blockchain needs to balance when it grows. Maintaining scalability and security relies on keeping the network size manageable. If the network size is too large, the equipment needed to run a full node is too much for an individual and leads to the enormous mining rigs we now see with Proof of Work blockchains. There are developments with Ethereum clients, like Geth's snapshots , which reduce the amount of space needed for clients. There is also a push to for light clients, or clients that can run on mobile phones or a browser. CAP Theorem This is a fairly technical concept and can be challenging to understand. To put it simply, the CAP Theorem states that when a distributed network forks (also called a partition ), the network must either sacrifice consistency or availability. For example, if a blockchain network forks / partitions into two separate chains, you cannot expect those chains to both continue to mine new transactions ( Availability ) and stay consistent ( Consistency ) with each other. You don't need to be an expert in the CAP theorem, really just be aware of its existence and generally how it affects distributed networks. If you'd like to learn more, please see the links in \"Additional Material\" below. Scalability As we've mentioned before, blockchain consensus mechanisms, particularly Proof of Work, are limited by the amount of transactions they can process. If the block size (the amount of transactions processed) increases, then mining will become more centralized and only available to those with significant resources. However, the current transaction throughput (the amount of transactions processed) is not enough to compete against current mainstream financial payment mechanisms. There are significant challenges, mainly how to make Ethereum more light-client friendly. Meaning: how can we reduce the amount of resources needed to provide decentralized consensus? 51% attacks In \"11. Calculations\" of the Bitcoin whitepaper, Nakamoto discusses the possibility of something called a \"51% attack\". This is the mathematical possibility of a malicious actor, who controls 51% or more of the network's hash rate, to both reorder some recent blocks and create a new, valid block including those tampered transactions. To be clear, this has not happened with Bitcoin or any major network, but it does exist as a possibility. Also, controlling 51% of a network's hash rate is only the entrance fee for doing such an attack. It also requires an enormous amount of coordination and subversion to make sure the attack is not noticed. Last, Proof of Work provides an economic incentive for the malicious actor with over 51% of the mining rate to actually produce valid blocks, rather than trying a re-organization attack. Miner Extracted Value This is a more recent concern in the Ethereum community and may be too technical for this part of the course so no worries if you don't get this yet. Put simply, a user may increase the miner's fee of a transaction to entice a miner to include the transaction in a block. That user can use this \"frontrunning\" effect to target users making sophisticated trades. With the increasing sophistication of Ethereum transactions, many feel MEV poses as serious issue to the ecosystem. Please see links below for more resources if you're interested. Conclusion Blockchain consensus protocols, as kicked off by Proof of Work but including Proof of Stake and others, are the last primitive we need in our mental model to complete our blockchain framework. Now that we have both cryptography and distributed computing in our toolkit, we will now see how we can build a generalizable framework to understanding almost any blockchain network we encounter. Additional Material ### Introductory Article: The Meaning of Decentralization Article: Sharding Discusses the scalability trilemma Release Notes: Geth 1.10.0 Describes the snapshot feature implemented in Geth Reddit: Making Ethereum More Lightclient Friendly Article: The CAP Theorem (Dean Eigenmann) Another great post from the Distributed Systems newsletter describing the CAP theorem in a general way. Dean discusses how CAP theorem is particularly important with e-commerce like Amazon. Article: The CAP FAQ A nice introductory article requiring some network knowledge. Article: Eth2 Vision: The Challenge of Decentralized Scaling Scroll down a bit to see a diagram showing the \"scalability trilemma\" Forum: How to Make the Ecosystem more Light-Client Friendly A Reddit discussion about Ethereum light-clients from 2021. Article: What Everyone Gets Wrong about 51% Attacks (Dankrad Feist) General discussion around 51% attacks, what they are, what they're not, and how Proof of Stake creates checkpoints which could avoid an adversarial re-organization attack. Article: Flashbots: Frontrunning the MEV Crisis A great introductory discussion by the Flashbots research group dedicated to issue of Miner Extracted Value. Interactive: Explore MEV in Real-time A visualization put together by Flashbots to document what they call MEV in real-time. Article: Why Ethereum\u2019s MEV Problem Is Way Worse Than You Think Opinion article describing the potential future problems facing Ethereum if it doesn't address Miner Extracted Value issues. Video: WTF is MEV? Introduction to Miner Extracted Value from Charlie Noyes at a MEV Summit. This video starts at his talk but also includes the rest of the summit, which you don't have to watch! Video: MEV Walkthrough with FlashBots Another walkthrough of MEV from Flashbots ### Advanced: Distributed Systems Wiki: Distributed Systems Reading List Strong technical and academic discussion around distributed systems Article: How Complex Systems Fail A series of simple statements referring to the management of chaos in complex systems. Highly generalized, but still has a number of gems. Tutorial: Building a Distributed Turn-Based Game System Fun tutorial around using distributed system language Elixir. Wikipedia: Beer Distribution Game A cute, general educational game teaching about the challenges of a distributed system using a common supply chain scenario. Wiki: Sharding FAQ (Ethereum Foundation) First mention of the \"scalability trilemma\" a bit technical, however! Article: You Can't Sacrifice Partition Tolerance Code: \"11. Calcuations\" Bitcoin whitepaper The section where Nakamoto describes the race conditions needed to achieve a 51% attack. Academic Article: Flash Boys 2.0 An in-depth discussion of the Miner Extracted Value theory. Wiki: Resources from Flashbots about MEV Article: Ethereum is a Dark Forest A long narrative account describing white-hat hackers attempt to frontrun the frontrunners. A good primary account of the challenges of Miner Extracted Value.","title":"Index"},{"location":"S01-fundamentals/M3-consensus/L9a-consensus-conclusion/#consensus-conclusion","text":"Hopefully by now you feel like you have a sense of how distributed consensus works in a traditional network and how blockchains have innovated consensus protocols. While cryptographic primitives allow blockchain users to secure and validate current transactions, blockchain consensus protocols allow for a blockchain network to maintain a public ledger (the global state of the blockchain) in a decentralized way.","title":"Consensus Conclusion"},{"location":"S01-fundamentals/M3-consensus/L9a-consensus-conclusion/#challenges-of-consensus-in-distributed-networks","text":"While blockchain consensus protocols have made great strides in decentralized networks, there are still some unsolved issues they're facing. Some of these (like the CAP theorem and forks) affect all general distributed networks while others, like Miner Extracted Value and 51% attacks, are specific to public blockchains. Here's a sampling and brief description of these challenges. Forks As we mentioned in a previous section, Proof of Work and other blockchain consensus mechanisms can lead to network forks (Note: In general computing networking, forks are also called partitions ). Some of these forks are voluntary (such as network upgrades), accidental (a node receives two valid but different new blocks) or adversarial (network participants purposefully breakaway from the main network to create a separate chain). While forks are common in all distributed systems, with blockchain networks they can be particuarly painful but are also necessary update mechanisms. Network Size The Scalability Trilemma details the different elements a blockchain needs to balance when it grows. Maintaining scalability and security relies on keeping the network size manageable. If the network size is too large, the equipment needed to run a full node is too much for an individual and leads to the enormous mining rigs we now see with Proof of Work blockchains. There are developments with Ethereum clients, like Geth's snapshots , which reduce the amount of space needed for clients. There is also a push to for light clients, or clients that can run on mobile phones or a browser. CAP Theorem This is a fairly technical concept and can be challenging to understand. To put it simply, the CAP Theorem states that when a distributed network forks (also called a partition ), the network must either sacrifice consistency or availability. For example, if a blockchain network forks / partitions into two separate chains, you cannot expect those chains to both continue to mine new transactions ( Availability ) and stay consistent ( Consistency ) with each other. You don't need to be an expert in the CAP theorem, really just be aware of its existence and generally how it affects distributed networks. If you'd like to learn more, please see the links in \"Additional Material\" below. Scalability As we've mentioned before, blockchain consensus mechanisms, particularly Proof of Work, are limited by the amount of transactions they can process. If the block size (the amount of transactions processed) increases, then mining will become more centralized and only available to those with significant resources. However, the current transaction throughput (the amount of transactions processed) is not enough to compete against current mainstream financial payment mechanisms. There are significant challenges, mainly how to make Ethereum more light-client friendly. Meaning: how can we reduce the amount of resources needed to provide decentralized consensus? 51% attacks In \"11. Calculations\" of the Bitcoin whitepaper, Nakamoto discusses the possibility of something called a \"51% attack\". This is the mathematical possibility of a malicious actor, who controls 51% or more of the network's hash rate, to both reorder some recent blocks and create a new, valid block including those tampered transactions. To be clear, this has not happened with Bitcoin or any major network, but it does exist as a possibility. Also, controlling 51% of a network's hash rate is only the entrance fee for doing such an attack. It also requires an enormous amount of coordination and subversion to make sure the attack is not noticed. Last, Proof of Work provides an economic incentive for the malicious actor with over 51% of the mining rate to actually produce valid blocks, rather than trying a re-organization attack. Miner Extracted Value This is a more recent concern in the Ethereum community and may be too technical for this part of the course so no worries if you don't get this yet. Put simply, a user may increase the miner's fee of a transaction to entice a miner to include the transaction in a block. That user can use this \"frontrunning\" effect to target users making sophisticated trades. With the increasing sophistication of Ethereum transactions, many feel MEV poses as serious issue to the ecosystem. Please see links below for more resources if you're interested.","title":"Challenges of Consensus in Distributed Networks"},{"location":"S01-fundamentals/M3-consensus/L9a-consensus-conclusion/#conclusion","text":"Blockchain consensus protocols, as kicked off by Proof of Work but including Proof of Stake and others, are the last primitive we need in our mental model to complete our blockchain framework. Now that we have both cryptography and distributed computing in our toolkit, we will now see how we can build a generalizable framework to understanding almost any blockchain network we encounter.","title":"Conclusion"},{"location":"S01-fundamentals/M3-consensus/L9a-consensus-conclusion/#additional-material","text":"### Introductory Article: The Meaning of Decentralization Article: Sharding Discusses the scalability trilemma Release Notes: Geth 1.10.0 Describes the snapshot feature implemented in Geth Reddit: Making Ethereum More Lightclient Friendly Article: The CAP Theorem (Dean Eigenmann) Another great post from the Distributed Systems newsletter describing the CAP theorem in a general way. Dean discusses how CAP theorem is particularly important with e-commerce like Amazon. Article: The CAP FAQ A nice introductory article requiring some network knowledge. Article: Eth2 Vision: The Challenge of Decentralized Scaling Scroll down a bit to see a diagram showing the \"scalability trilemma\" Forum: How to Make the Ecosystem more Light-Client Friendly A Reddit discussion about Ethereum light-clients from 2021. Article: What Everyone Gets Wrong about 51% Attacks (Dankrad Feist) General discussion around 51% attacks, what they are, what they're not, and how Proof of Stake creates checkpoints which could avoid an adversarial re-organization attack. Article: Flashbots: Frontrunning the MEV Crisis A great introductory discussion by the Flashbots research group dedicated to issue of Miner Extracted Value. Interactive: Explore MEV in Real-time A visualization put together by Flashbots to document what they call MEV in real-time. Article: Why Ethereum\u2019s MEV Problem Is Way Worse Than You Think Opinion article describing the potential future problems facing Ethereum if it doesn't address Miner Extracted Value issues. Video: WTF is MEV? Introduction to Miner Extracted Value from Charlie Noyes at a MEV Summit. This video starts at his talk but also includes the rest of the summit, which you don't have to watch! Video: MEV Walkthrough with FlashBots Another walkthrough of MEV from Flashbots ### Advanced: Distributed Systems Wiki: Distributed Systems Reading List Strong technical and academic discussion around distributed systems Article: How Complex Systems Fail A series of simple statements referring to the management of chaos in complex systems. Highly generalized, but still has a number of gems. Tutorial: Building a Distributed Turn-Based Game System Fun tutorial around using distributed system language Elixir. Wikipedia: Beer Distribution Game A cute, general educational game teaching about the challenges of a distributed system using a common supply chain scenario. Wiki: Sharding FAQ (Ethereum Foundation) First mention of the \"scalability trilemma\" a bit technical, however! Article: You Can't Sacrifice Partition Tolerance Code: \"11. Calcuations\" Bitcoin whitepaper The section where Nakamoto describes the race conditions needed to achieve a 51% attack. Academic Article: Flash Boys 2.0 An in-depth discussion of the Miner Extracted Value theory. Wiki: Resources from Flashbots about MEV Article: Ethereum is a Dark Forest A long narrative account describing white-hat hackers attempt to frontrun the frontrunners. A good primary account of the challenges of Miner Extracted Value.","title":"Additional Material"},{"location":"S01-fundamentals/M4-ag-blockchain/L1-mental-model/","text":"Mental Model for Basic Blockchain Architecture Let's take a look at this diagram of a blockchain node, which is not specific to any particular cryptocurrency and could be on any blockchain network: Above the dotted line is the distributed, peer-to-peer network with which the node is interacting. As we mentioned previously, the fundamental unit of communication is the transaction, (commonly shortened to txn ), which the node is both sending and receiving from the network. Below the line are all the primitives we have discussed in this section. We have the cryptographic primitives used in the network identity, and those used to validate transactions. We also have the consensus protocol, which is agreed upon by the network, and which the node will use to check the validity of the blocks. If the block is valid, the node will update its network state with the changes the valid transactions make. If this node is a miner, the consensus mechanism will also work to produce a valid block. Let's now zoom out and see a simplified version of the larger network: The nodes have a different color to show they have unique identities, which are created by the cryptographic keys they use in their network identity. While the nodes have different identities, please note that they all have the same \"Consensus Protocol.\" This is the mechanism they have all agreed to use to maintain and update their network state. However, it's only successful if everyone is using it and coming to agreement about the network state. Luckily, this network we are looking at is all in agreement about its state. Please notice the middle of the diagram, the Emergent Properties . It's easy to forget that the network state and the network consensus are not a set, static property. Instead, they are a constantly evolving and mutating entity that changes with each transaction that is confirmed by the consensus protocol then propagated to the rest of the network. In our everyday life, we're more likely to encounter centralized entities attesting to a state. Your bank tells you your balance is a certain number, etc. With distributed networks, the network state is not something that's dictated by one centralized force. Instead, it's something that emerges from all the networks of participants, sometimes numbering in the millions, passing transactions, valid blocks and gradually shifting from one network state to the next. In the next section, we'll talk about how some network configurations change and why. But don't forget that, for every blockchain network, there is a generalizable structure you can isolate and use to identify what's different or the same. This will help you discern what networks are good for what purpose, how stable a network may be, or what improvements or innovations will change which part of a network. Additional Material Interactive Code: Building a Blockchain (Josh Crites, ConsenSys Academy) Interactive notebook where you can deepen your understanding and experiment to see how their properties are essential for building blockchains Interactive Code: Anders Blockchain A great, web-based interactive tutorial going over fundamentals of Proof of Work consensus including block production through hashing and distributed blockchains Code Tutorial: Build Your Own Blockchain Andrej Karpathy, who's done some great machine learning tutorials, built this tutorial walking through building the Bitcoin network using Python.","title":"Index"},{"location":"S01-fundamentals/M4-ag-blockchain/L1-mental-model/#mental-model-for-basic-blockchain-architecture","text":"Let's take a look at this diagram of a blockchain node, which is not specific to any particular cryptocurrency and could be on any blockchain network: Above the dotted line is the distributed, peer-to-peer network with which the node is interacting. As we mentioned previously, the fundamental unit of communication is the transaction, (commonly shortened to txn ), which the node is both sending and receiving from the network. Below the line are all the primitives we have discussed in this section. We have the cryptographic primitives used in the network identity, and those used to validate transactions. We also have the consensus protocol, which is agreed upon by the network, and which the node will use to check the validity of the blocks. If the block is valid, the node will update its network state with the changes the valid transactions make. If this node is a miner, the consensus mechanism will also work to produce a valid block. Let's now zoom out and see a simplified version of the larger network: The nodes have a different color to show they have unique identities, which are created by the cryptographic keys they use in their network identity. While the nodes have different identities, please note that they all have the same \"Consensus Protocol.\" This is the mechanism they have all agreed to use to maintain and update their network state. However, it's only successful if everyone is using it and coming to agreement about the network state. Luckily, this network we are looking at is all in agreement about its state. Please notice the middle of the diagram, the Emergent Properties . It's easy to forget that the network state and the network consensus are not a set, static property. Instead, they are a constantly evolving and mutating entity that changes with each transaction that is confirmed by the consensus protocol then propagated to the rest of the network. In our everyday life, we're more likely to encounter centralized entities attesting to a state. Your bank tells you your balance is a certain number, etc. With distributed networks, the network state is not something that's dictated by one centralized force. Instead, it's something that emerges from all the networks of participants, sometimes numbering in the millions, passing transactions, valid blocks and gradually shifting from one network state to the next. In the next section, we'll talk about how some network configurations change and why. But don't forget that, for every blockchain network, there is a generalizable structure you can isolate and use to identify what's different or the same. This will help you discern what networks are good for what purpose, how stable a network may be, or what improvements or innovations will change which part of a network.","title":"Mental Model for Basic Blockchain Architecture"},{"location":"S01-fundamentals/M4-ag-blockchain/L1-mental-model/#additional-material","text":"Interactive Code: Building a Blockchain (Josh Crites, ConsenSys Academy) Interactive notebook where you can deepen your understanding and experiment to see how their properties are essential for building blockchains Interactive Code: Anders Blockchain A great, web-based interactive tutorial going over fundamentals of Proof of Work consensus including block production through hashing and distributed blockchains Code Tutorial: Build Your Own Blockchain Andrej Karpathy, who's done some great machine learning tutorials, built this tutorial walking through building the Bitcoin network using Python.","title":"Additional Material"},{"location":"S01-fundamentals/M4-ag-blockchain/L2-configurations/","text":"Configurations for Different Blockchain Networks Now that we have a general model of a blockchain, when we encounter a new network, we know which questions to ask. Some suggested parts of the model you could build on: Nodes and Roles What are the different roles in the network for nodes? What are the ways the nodes join the network and acquire their different roles? Consensus Mechanism Always good to know for a blockchain network, will typically let you know whether a network is public, private or consortium. It typically also lets you know the processing limit for the network. The lower the trust assumptions, usually the more limited the processing limit (To be clear, not always the case). Periods We mentioned Block Production and Block Propagation as two general periods in Proof of Work. In any network, what are the different periods the network goes through as it achieves distributed consensus? Cryptographic Primitives This is very technical and advanced, but knowing what cryptographic family and implementation the network uses for its hashing and encryption can shed some light on a network. Mainly, if a network is using zero-knowledge proofs (which we'll learn about later) or something dramatically different from another network, that's good to know. Level of Decentralization This is a fuzzier variable and may involve incorporating the above data points to determine the level of decentralization. Or, the network is private or a testnet and will openly state that it's more centralized since that's appropriate for its function. Reason for Being Another fuzzy variable but it can be very telling to ask why another blockchain network needs to exist. Not because any are perfect, but rather because the answer will hopefully provide some more context into how the network is different from networks you are more familiar with. That way, you can port over what you already know about your favorite blockchain network to better understand another. Other variables include: Governance Structure (How does the network community decide on updates, fixes, etc.) Developer community size and support General community size and support Network size (How many nodes are there?) Open or Closed Source (Can anyone view or contribute to the implementation code online?) Below is an image showing a rough comparison of a few popular blockchain networks. Looking over it, you may see the benefit of having a set series of variables to analyze multiple networks. There aren't too many things that can change and those that do should have something to tell you about the purpose of the network and any strengths or weaknesses it might have: The other aspect of comparing blockchains is the concept of crosschain compatibility or blockchain interoperability. This is the ability of public blockchains to share network data with each other. We're living in an increasingly multi-chain world, where there are many significant blockchain networks. Rather than trying to have one chain monopolize, blockchain interoperability seeks to leverage different strengths and minimize weaknesses of the existing chains. We'll discuss this in more detail in a later section. Additional Materials Article: Secp256k1 (River Financial) Description of the Elliptic Curve used by Ethereum and Bitcoin. Chart: Cryptography Behind Cryptocurrencies A table of which cryptography is used with major blockchain networks. Article: Blockchain Interoperability: Why is Cross Chain Technology Important? (101 Blockchains) A brief introduction to blockchain interoperability. Article: Understanding Cross Chain Communication (Ivan on Tech) Another overview of cross chain communication, including bridges.","title":"Index"},{"location":"S01-fundamentals/M4-ag-blockchain/L2-configurations/#configurations-for-different-blockchain-networks","text":"Now that we have a general model of a blockchain, when we encounter a new network, we know which questions to ask. Some suggested parts of the model you could build on: Nodes and Roles What are the different roles in the network for nodes? What are the ways the nodes join the network and acquire their different roles? Consensus Mechanism Always good to know for a blockchain network, will typically let you know whether a network is public, private or consortium. It typically also lets you know the processing limit for the network. The lower the trust assumptions, usually the more limited the processing limit (To be clear, not always the case). Periods We mentioned Block Production and Block Propagation as two general periods in Proof of Work. In any network, what are the different periods the network goes through as it achieves distributed consensus? Cryptographic Primitives This is very technical and advanced, but knowing what cryptographic family and implementation the network uses for its hashing and encryption can shed some light on a network. Mainly, if a network is using zero-knowledge proofs (which we'll learn about later) or something dramatically different from another network, that's good to know. Level of Decentralization This is a fuzzier variable and may involve incorporating the above data points to determine the level of decentralization. Or, the network is private or a testnet and will openly state that it's more centralized since that's appropriate for its function. Reason for Being Another fuzzy variable but it can be very telling to ask why another blockchain network needs to exist. Not because any are perfect, but rather because the answer will hopefully provide some more context into how the network is different from networks you are more familiar with. That way, you can port over what you already know about your favorite blockchain network to better understand another. Other variables include: Governance Structure (How does the network community decide on updates, fixes, etc.) Developer community size and support General community size and support Network size (How many nodes are there?) Open or Closed Source (Can anyone view or contribute to the implementation code online?) Below is an image showing a rough comparison of a few popular blockchain networks. Looking over it, you may see the benefit of having a set series of variables to analyze multiple networks. There aren't too many things that can change and those that do should have something to tell you about the purpose of the network and any strengths or weaknesses it might have: The other aspect of comparing blockchains is the concept of crosschain compatibility or blockchain interoperability. This is the ability of public blockchains to share network data with each other. We're living in an increasingly multi-chain world, where there are many significant blockchain networks. Rather than trying to have one chain monopolize, blockchain interoperability seeks to leverage different strengths and minimize weaknesses of the existing chains. We'll discuss this in more detail in a later section.","title":"Configurations for Different Blockchain Networks"},{"location":"S01-fundamentals/M4-ag-blockchain/L2-configurations/#additional-materials","text":"Article: Secp256k1 (River Financial) Description of the Elliptic Curve used by Ethereum and Bitcoin. Chart: Cryptography Behind Cryptocurrencies A table of which cryptography is used with major blockchain networks. Article: Blockchain Interoperability: Why is Cross Chain Technology Important? (101 Blockchains) A brief introduction to blockchain interoperability. Article: Understanding Cross Chain Communication (Ivan on Tech) Another overview of cross chain communication, including bridges.","title":"Additional Materials"},{"location":"S01-fundamentals/M4-ag-blockchain/L3-public-private-networks/","text":"Public and Private Blockchains Please note that there is a subgroup of private networks known as testnets. Testnets are \"used by protocol developers or smart contract developers to test both protocol upgrades as well as potential smart contracts in a production-like environment before deployment to Mainnet.\" https://streamable.com/ar8ljg","title":"Index"},{"location":"S01-fundamentals/M4-ag-blockchain/L3-public-private-networks/#public-and-private-blockchains","text":"Please note that there is a subgroup of private networks known as testnets. Testnets are \"used by protocol developers or smart contract developers to test both protocol upgrades as well as potential smart contracts in a production-like environment before deployment to Mainnet.\" https://streamable.com/ar8ljg","title":"Public and Private Blockchains"},{"location":"S01-fundamentals/M4-ag-blockchain/L4-when-to-use/","text":"When To Use a Blockchain? https://streamable.com/qbm9ih","title":"Index"},{"location":"S01-fundamentals/M4-ag-blockchain/L4-when-to-use/#when-to-use-a-blockchain","text":"https://streamable.com/qbm9ih","title":"When To Use a Blockchain?"},{"location":"S01-fundamentals/M5-bitcoin/L1-history-and-development/","text":"================================ Please note: People have written books about Bitcoin's history and development and this is just a section of our course. We'll be the first to admit that an overview of Bitcoin requires discretion on our part. Opinionated or controversial comments are flagged as best we can but, as always, we're hoping mainly to give a overview of the major points. Inevitably, we'll miss something. \"Bitcoin is Old Technology\" As we've mentioned frequently, Bitcoin relies on decades of technological development. This has led to a meme \"Bitcoin is Old Technology\": Satoshi Nakamoto was aware of all these developments, and references them throughout their whitepaper. But Bitcoin actually started on a listserve and with Nakamoto sharing a piece of software they were building. It was initially simply called \"Bitcoin\" and was built using C++. Nakamoto also encouraged others to run the software and began gathering the early developers who ran the first distributed network. Once the software was stable, Nakamoto released a whitepaper describing the concepts underpinning the software and referencing some of the older technologies it drew upon. By the release of the whitepaper, there was a growing community of developers interested in Bitcoin and discussing its future. Famously, Nakamoto stepped back from the project in early 2011. In April of that year, Nakamoto posted their last update to Bitcoin Core, as the software was now known and gave developer credentials to the now-lead technical developer, Gavin Andresen. ( source ) Many have speculated about Satoshi Nakamoto's identity but their identity has never been definitively proven. There is a significant amount of bitcoin (some estimates say around one million bitcoin) Nakamoto mined during their time running the Bitcoin Core software. It's considered to be the best identity test for anyone claiming to be Nakamoto: Sign a cryptographic digital message with the private key associated with this bitcoin. It has never been done! Basic Technical Features We'll briefly touch on two main technical parts of the Bitcoin network: The UTXO transaction model and the Script smart-contract language. The Unspent Transaction Output or UTXO model is the fundamental building block of transactions in the Bitcoin network. Per Wikipedia: \"Each UTXO is analogous to a coin, and holds a certain amount of value in its respective currency. Each UTXO represents a chain of ownership implemented as a chain of digital signatures where the owner signs a message (transaction) transferring ownership of their UTXO to the receiver's public key.\" The UTXO model is in contrast to the account model that Ethereum tracks value in the network Many don't realize this, but Bitcoin does actually technically have a programming language it uses, called Script, which is based off the Forth programming language. It's very limited in its capacity, but you can read about some of its capacity in Mastering Bitcoin in the \"Advanced Transactions and Scripting\" chapter. Conclusion It's sometimes easy for others to find fault with Bitcoin and the Bitcoin community. However, it's important to note Bitcoin's contribution to the world, both specifically to blockchains but also to distributed networks generally. We can't go as deep as we'd like to (we can't, but we'd like to talk about the Segregated Witness development and the more recent Taproot fork), but we'd encourage you to at least checkout the whitepaper. At this point, you should be able to understand all the concepts in it! Here are some great resources for reading the whitepaper, which can be intimidating on its own: Fermat's Library: Bitcoin Whitepaper Annotated Genius.com's Annotation of Bitcoin White Paper Additional Material ### History and Nakamoto Wikipedia: Bitcoin A general overview of Bitcoin from our favorite hive mind encyclopedia. Article: Exploring Bitcoin's History A very long, but thorough, article discussing all the technology building up to Bitcoin, including TCP/IP, Elliptic Curve Cryptography, time-stamp servers, smart contracts and more. Article: The Crypto-Currency An article discussing Bitcoin and it's mysterious creator Satoshi Nakamoto, from October 2011 Article: What Bitcoin Is and Why It Matters (MIT) Article: What Happened When Bitcoin Creator Satoshi Nakamoto Disappeared (Bitcoin Magazine) An article charting the rise of Nakamoto, the community of developers who grew around the project, and the eventual disappearance of Nakamoto from the project in 2011. ### Technical Features and Development Book: Mastering Bitcoin Considered to be the best-in-class introduction to Bitcoin development. Tutorial: Advanced Transactions Section from \"Mastering Bitcoin\" about Script's more advanced features. ### General Resources Online Course: What is Money? (UC Berkeley) Article: You Don't Understand Bitcoin Because You Think Money is Real A favorite article of ours! Article: What is Money? (London Review of Books) Sort-of paywalled, but a think piece about the implications of Bitcoin from April 2016. Article: What the Heck is UTXO?","title":"Index"},{"location":"S01-fundamentals/M5-bitcoin/L1-history-and-development/#bitcoin-is-old-technology","text":"As we've mentioned frequently, Bitcoin relies on decades of technological development. This has led to a meme \"Bitcoin is Old Technology\": Satoshi Nakamoto was aware of all these developments, and references them throughout their whitepaper. But Bitcoin actually started on a listserve and with Nakamoto sharing a piece of software they were building. It was initially simply called \"Bitcoin\" and was built using C++. Nakamoto also encouraged others to run the software and began gathering the early developers who ran the first distributed network. Once the software was stable, Nakamoto released a whitepaper describing the concepts underpinning the software and referencing some of the older technologies it drew upon. By the release of the whitepaper, there was a growing community of developers interested in Bitcoin and discussing its future. Famously, Nakamoto stepped back from the project in early 2011. In April of that year, Nakamoto posted their last update to Bitcoin Core, as the software was now known and gave developer credentials to the now-lead technical developer, Gavin Andresen. ( source ) Many have speculated about Satoshi Nakamoto's identity but their identity has never been definitively proven. There is a significant amount of bitcoin (some estimates say around one million bitcoin) Nakamoto mined during their time running the Bitcoin Core software. It's considered to be the best identity test for anyone claiming to be Nakamoto: Sign a cryptographic digital message with the private key associated with this bitcoin. It has never been done!","title":"\"Bitcoin is Old Technology\""},{"location":"S01-fundamentals/M5-bitcoin/L1-history-and-development/#basic-technical-features","text":"We'll briefly touch on two main technical parts of the Bitcoin network: The UTXO transaction model and the Script smart-contract language. The Unspent Transaction Output or UTXO model is the fundamental building block of transactions in the Bitcoin network. Per Wikipedia: \"Each UTXO is analogous to a coin, and holds a certain amount of value in its respective currency. Each UTXO represents a chain of ownership implemented as a chain of digital signatures where the owner signs a message (transaction) transferring ownership of their UTXO to the receiver's public key.\" The UTXO model is in contrast to the account model that Ethereum tracks value in the network Many don't realize this, but Bitcoin does actually technically have a programming language it uses, called Script, which is based off the Forth programming language. It's very limited in its capacity, but you can read about some of its capacity in Mastering Bitcoin in the \"Advanced Transactions and Scripting\" chapter.","title":"Basic Technical Features"},{"location":"S01-fundamentals/M5-bitcoin/L1-history-and-development/#conclusion","text":"It's sometimes easy for others to find fault with Bitcoin and the Bitcoin community. However, it's important to note Bitcoin's contribution to the world, both specifically to blockchains but also to distributed networks generally. We can't go as deep as we'd like to (we can't, but we'd like to talk about the Segregated Witness development and the more recent Taproot fork), but we'd encourage you to at least checkout the whitepaper. At this point, you should be able to understand all the concepts in it! Here are some great resources for reading the whitepaper, which can be intimidating on its own: Fermat's Library: Bitcoin Whitepaper Annotated Genius.com's Annotation of Bitcoin White Paper","title":"Conclusion"},{"location":"S01-fundamentals/M5-bitcoin/L1-history-and-development/#additional-material","text":"### History and Nakamoto Wikipedia: Bitcoin A general overview of Bitcoin from our favorite hive mind encyclopedia. Article: Exploring Bitcoin's History A very long, but thorough, article discussing all the technology building up to Bitcoin, including TCP/IP, Elliptic Curve Cryptography, time-stamp servers, smart contracts and more. Article: The Crypto-Currency An article discussing Bitcoin and it's mysterious creator Satoshi Nakamoto, from October 2011 Article: What Bitcoin Is and Why It Matters (MIT) Article: What Happened When Bitcoin Creator Satoshi Nakamoto Disappeared (Bitcoin Magazine) An article charting the rise of Nakamoto, the community of developers who grew around the project, and the eventual disappearance of Nakamoto from the project in 2011. ### Technical Features and Development Book: Mastering Bitcoin Considered to be the best-in-class introduction to Bitcoin development. Tutorial: Advanced Transactions Section from \"Mastering Bitcoin\" about Script's more advanced features. ### General Resources Online Course: What is Money? (UC Berkeley) Article: You Don't Understand Bitcoin Because You Think Money is Real A favorite article of ours! Article: What is Money? (London Review of Books) Sort-of paywalled, but a think piece about the implications of Bitcoin from April 2016. Article: What the Heck is UTXO?","title":"Additional Material"},{"location":"S01-fundamentals/M6-wallets/L1-intro-to-mm/","text":"Introduction to MetaMask How to use MetaMask - youtube.com/watch?v=Af_lQ1zUnoM","title":"Index"},{"location":"S01-fundamentals/M6-wallets/L1-intro-to-mm/#introduction-to-metamask","text":"How to use MetaMask - youtube.com/watch?v=Af_lQ1zUnoM","title":"Introduction to MetaMask"},{"location":"S01-fundamentals/M6-wallets/L2-mm-lavamoat/","text":"How Does MetaMask Keep Your Keys Safe? There are more Ethereum wallets available now than, say, a few years ago. What makes MetaMask special? In the next two sections, we're going to prove to you why MetaMask holds a characteristic that raises it above the rest. Namely, MetaMask has taken more steps than any digital cryptocurrency wallet to protect its users. As we hope you realize by now, this is of the utmost importance in the Web 3 paradigm. If we are decentralizing systems, that also means users take on much more security concerns than they are used to having on the web. It's a tall order for users, but even more massive for those building tooling used as extensively as MetaMask. Luckily, the MetaMask team is working with engineers in the broader JavaScript community who have been focussing on these issues for quite some time. All decentralized systems require a way to safely persist state and capture intent, not just blockchains, and the MetaMask team has been able to draw from decades of experience and contribute their own innovations. All of this helps push us towards a broader decentralized future. At the end of the day, MetaMask, is a user consent tool with a broad impact beyond public blockchains. With the user's private keys in the browser, you may assume the private key at some point is passed outside of MetaMask. However, this is never the case. To do so would invite imminent hack. But how to make sure the keys never leave MetaMask? You have to build something very difficult to penetrate around MetaMask. Enter... LavaMoat! From the repo: LavaMoat is a set of tools for securing JavaScript projects against a category of attacks called software supply chain attacks. This genre of attack occurs when a malicious dependency makes its way into a developer's application. An attacker could use the vulnerable dependency to then steal important secrets like credit card numbers, private keys, or personal data. These attacks have occurred in the software system, in part due to a larger phenomenon exemplified by the wide use of npm install when working on projects. Tons of warnings and errors fly by and, while the first few times it may be alarming, it's easy to become used to these warnings and ignore them. However, each of these dependencies can be a potential backdoor! A common sight Major ransomware attacks like the SolarWinds attack on US Federal Government Systems show us that the supply chain issue is not just restricted to JavaScript or cryptocurrency projects. Supply chain attacks present a significant risk for the developers and users of wallets and apps. In order to help mitigate the risk of such an attack MetaMask is building a suite of tools that range from a node-based runtime, to plugins for common app bundlers (eg webpack, browserify), to dependency analysis and visualization tools. The goal of LavaMoat is to bring added protections to modern JavaScript apps without having to rewrite them from scratch and automate a good first-start security configuration. Additional Material Video: Introduction to LavaMoat (DevCon V) Video: LavaMoat: Securing Your Dependency Graph Code: LavaMoat GitHub Repo","title":"Index"},{"location":"S01-fundamentals/M6-wallets/L2-mm-lavamoat/#how-does-metamask-keep-your-keys-safe","text":"There are more Ethereum wallets available now than, say, a few years ago. What makes MetaMask special? In the next two sections, we're going to prove to you why MetaMask holds a characteristic that raises it above the rest. Namely, MetaMask has taken more steps than any digital cryptocurrency wallet to protect its users. As we hope you realize by now, this is of the utmost importance in the Web 3 paradigm. If we are decentralizing systems, that also means users take on much more security concerns than they are used to having on the web. It's a tall order for users, but even more massive for those building tooling used as extensively as MetaMask. Luckily, the MetaMask team is working with engineers in the broader JavaScript community who have been focussing on these issues for quite some time. All decentralized systems require a way to safely persist state and capture intent, not just blockchains, and the MetaMask team has been able to draw from decades of experience and contribute their own innovations. All of this helps push us towards a broader decentralized future. At the end of the day, MetaMask, is a user consent tool with a broad impact beyond public blockchains. With the user's private keys in the browser, you may assume the private key at some point is passed outside of MetaMask. However, this is never the case. To do so would invite imminent hack. But how to make sure the keys never leave MetaMask? You have to build something very difficult to penetrate around MetaMask. Enter... LavaMoat! From the repo: LavaMoat is a set of tools for securing JavaScript projects against a category of attacks called software supply chain attacks. This genre of attack occurs when a malicious dependency makes its way into a developer's application. An attacker could use the vulnerable dependency to then steal important secrets like credit card numbers, private keys, or personal data. These attacks have occurred in the software system, in part due to a larger phenomenon exemplified by the wide use of npm install when working on projects. Tons of warnings and errors fly by and, while the first few times it may be alarming, it's easy to become used to these warnings and ignore them. However, each of these dependencies can be a potential backdoor! A common sight Major ransomware attacks like the SolarWinds attack on US Federal Government Systems show us that the supply chain issue is not just restricted to JavaScript or cryptocurrency projects. Supply chain attacks present a significant risk for the developers and users of wallets and apps. In order to help mitigate the risk of such an attack MetaMask is building a suite of tools that range from a node-based runtime, to plugins for common app bundlers (eg webpack, browserify), to dependency analysis and visualization tools. The goal of LavaMoat is to bring added protections to modern JavaScript apps without having to rewrite them from scratch and automate a good first-start security configuration.","title":"How Does MetaMask Keep Your Keys Safe?"},{"location":"S01-fundamentals/M6-wallets/L2-mm-lavamoat/#additional-material","text":"Video: Introduction to LavaMoat (DevCon V) Video: LavaMoat: Securing Your Dependency Graph Code: LavaMoat GitHub Repo","title":"Additional Material"}]}